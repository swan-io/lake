{"version":3,"file":"index-BODZWSz8.js","sources":["../../../node_modules/@swan-io/chicane/dist/index.mjs"],"sourcesContent":["import murmurhash from '@emotion/hash';\nimport { createContext, forwardRef, createElement, useSyncExternalStore, useMemo, useCallback, useId, useEffect, useContext } from 'react';\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js';\n\n// src/helpers.ts\nvar first = (value) => value[0];\nvar last = (value) => value[value.length - 1];\nvar identity = (value) => value;\nvar noop = () => {\n};\nvar isNonEmpty = (value) => value !== \"\";\nvar isParam = (value) => value.startsWith(\":\");\nvar ensureSlashPrefix = (value) => value[0] === \"/\" ? value : \"/\" + value;\nvar areParamsArrayEqual = (arrayA, arrayB) => arrayA.length === arrayB.length && arrayA.every((a, index) => a === arrayB[index]);\nvar getStableParamsKey = (params) => {\n  const keys = Object.keys(params);\n  return keys.length > 0 ? JSON.stringify(keys.sort().map((key) => [key, params[key]])) : \"\";\n};\nvar getRouteKey = (name, pathParams, searchParams) => {\n  const stableStart = name + getStableParamsKey(pathParams);\n  const stableEnd = getStableParamsKey(searchParams);\n  return `${murmurhash(stableStart)}-${murmurhash(stableEnd)}`;\n};\nvar areRouteEqual = (routeA, routeB) => (routeA == null ? void 0 : routeA.key) === (routeB == null ? void 0 : routeB.key);\nvar extractParamNameUnion = (paramName) => {\n  const bracketIndex = paramName.indexOf(\"{\");\n  if (bracketIndex > -1 && paramName.endsWith(\"}\")) {\n    return {\n      name: paramName.substring(0, bracketIndex),\n      union: paramName.substring(bracketIndex + 1, paramName.length - 1).split(\"|\").filter(isNonEmpty)\n    };\n  } else {\n    return { name: paramName };\n  }\n};\n\n// src/concatRoutes.ts\nvar addPrefixOnNonEmpty = (value, prefix) => value === \"\" ? value : prefix + value;\nvar concatRoutes = (routeA, routeB) => {\n  const prefixedPathA = ensureSlashPrefix(routeA[\"path\"]);\n  const prefixedPathB = ensureSlashPrefix(routeB[\"path\"]);\n  const unprefixedSearchA = routeA.search.substring(1);\n  const unprefixedSearchB = routeB.search.substring(1);\n  const path = prefixedPathA === \"/\" ? prefixedPathB : prefixedPathB === \"/\" ? prefixedPathA : prefixedPathA + prefixedPathB;\n  const search = unprefixedSearchA === \"\" ? unprefixedSearchB : unprefixedSearchA + addPrefixOnNonEmpty(unprefixedSearchB, \"&\");\n  return path + addPrefixOnNonEmpty(search, \"?\");\n};\n\n// src/search.ts\nvar decodeSearch = (search) => {\n  const params = new URLSearchParams(search);\n  const output = {};\n  for (const [key, value] of params) {\n    const existing = output[key];\n    if (existing != null) {\n      output[key] = typeof existing === \"string\" ? [existing, value] : existing.concat(value);\n    } else {\n      output[key] = value;\n    }\n  }\n  return output;\n};\nvar NO_VALUE_PARAM_REGEXP = /=&/g;\nvar FINISH_BY_EQUAL_REGEXP = /=$/g;\nvar encodeSearch = (search) => {\n  const keys = Object.keys(search);\n  if (keys.length === 0) {\n    return \"\";\n  }\n  const params = new URLSearchParams();\n  keys.sort();\n  for (const key of keys) {\n    const value = search[key];\n    if (value == null) {\n      continue;\n    }\n    if (typeof value === \"string\") {\n      params.append(key, value);\n    } else {\n      for (const item of value) {\n        params.append(key, item);\n      }\n    }\n  }\n  const output = params.toString().replace(NO_VALUE_PARAM_REGEXP, \"&\").replace(FINISH_BY_EQUAL_REGEXP, \"\");\n  if (output === \"\") {\n    return \"\";\n  }\n  return \"?\" + output;\n};\n\n// src/history.ts\nvar initialLocationHasChanged = false;\nvar parseRoute = (route) => {\n  const hashIndex = route.indexOf(\"#\");\n  const cleanRoute = ensureSlashPrefix(\n    hashIndex < 0 ? route : route.substring(0, hashIndex)\n  );\n  const searchIndex = cleanRoute.indexOf(\"?\");\n  if (searchIndex < 0) {\n    return { path: cleanRoute, search: \"\" };\n  }\n  return {\n    path: cleanRoute.substring(0, searchIndex),\n    search: cleanRoute.substring(searchIndex)\n  };\n};\nvar decodeLocation = (input) => {\n  const route = parseRoute(input);\n  const path = route.path.substring(1);\n  const parsedPath = path !== \"\" ? initialLocationHasChanged ? path.split(\"/\").map(decodeURIComponent) : path.split(\"/\").filter(isNonEmpty).map(decodeURIComponent) : [];\n  const parsedSearch = route.search !== \"\" ? decodeSearch(route.search) : {};\n  const rawPath = \"/\" + parsedPath.map(encodeURIComponent).join(\"/\");\n  const rawSearch = encodeSearch(parsedSearch);\n  const stringifiedLocation = rawPath + rawSearch;\n  return {\n    path: parsedPath,\n    search: parsedSearch,\n    raw: {\n      path: rawPath,\n      search: rawSearch\n    },\n    toString() {\n      return stringifiedLocation;\n    }\n  };\n};\nvar onBeforeUnload = (event) => {\n  event.preventDefault();\n  event.returnValue = \"\";\n};\nvar createBrowserHistory = () => {\n  const listeners = /* @__PURE__ */ new Set();\n  let blockers = [];\n  const globalHistory = window.history;\n  const globalLocation = window.location;\n  let currentLocation = decodeLocation(\n    globalLocation.pathname + globalLocation.search\n  );\n  const maybeUpdateLocation = () => {\n    const nextLocation = decodeLocation(\n      globalLocation.pathname + globalLocation.search\n    );\n    if (nextLocation.toString() === currentLocation.toString()) {\n      return;\n    }\n    initialLocationHasChanged = true;\n    const searchHasChanged = nextLocation.raw.search !== currentLocation.raw.search;\n    const search = searchHasChanged ? {} : currentLocation.search;\n    if (searchHasChanged) {\n      for (const key in nextLocation.search) {\n        if (Object.prototype.hasOwnProperty.call(nextLocation.search, key)) {\n          const value = nextLocation.search[key];\n          if (value == null) {\n            continue;\n          }\n          const prevValue = currentLocation.search[key];\n          if (prevValue == null || typeof prevValue === \"string\" || typeof value === \"string\" || !areParamsArrayEqual(value, prevValue)) {\n            search[key] = value;\n          } else {\n            search[key] = prevValue;\n          }\n        }\n      }\n    }\n    currentLocation = {\n      path: nextLocation.raw.path !== currentLocation.raw.path ? nextLocation.path : currentLocation.path,\n      search,\n      raw: nextLocation.raw,\n      toString: nextLocation.toString\n    };\n    listeners.forEach((listener) => listener(currentLocation));\n  };\n  window.addEventListener(\"popstate\", () => {\n    maybeUpdateLocation();\n  });\n  return {\n    get location() {\n      return currentLocation;\n    },\n    subscribe: (listener) => {\n      listeners.add(listener);\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n    push: (url) => {\n      const blocker = last(blockers);\n      if (blocker == null || window.confirm(blocker.message)) {\n        try {\n          globalHistory.pushState(null, \"\", url);\n        } catch {\n          globalLocation.assign(url);\n        }\n        maybeUpdateLocation();\n      }\n    },\n    replace: (url) => {\n      const blocker = last(blockers);\n      if (blocker == null || window.confirm(blocker.message)) {\n        globalHistory.replaceState(null, \"\", url);\n        maybeUpdateLocation();\n      }\n    },\n    block: (blocker) => {\n      blockers.push(blocker);\n      if (blockers.length === 1) {\n        window.addEventListener(\"beforeunload\", onBeforeUnload, {\n          capture: true\n        });\n      }\n      return () => {\n        blockers = blockers.filter(({ id }) => id !== blocker.id);\n        if (blockers.length === 0) {\n          window.removeEventListener(\"beforeunload\", onBeforeUnload, {\n            capture: true\n          });\n        }\n      };\n    }\n  };\n};\nvar history = typeof window !== \"undefined\" ? createBrowserHistory() : {\n  location: decodeLocation(\"/\"),\n  subscribe: () => noop,\n  push: noop,\n  replace: noop,\n  block: () => noop\n};\nvar getLocation = () => history.location;\nvar subscribeToLocation = history.subscribe;\nvar pushUnsafe = history.push;\nvar replaceUnsafe = history.replace;\nvar block = history.block;\nvar GetUniversalLocationContext = createContext(getLocation);\nvar GetUniversalLocationProvider = GetUniversalLocationContext.Provider;\nvar useGetUniversalLocation = () => useContext(GetUniversalLocationContext);\nvar useLocation = () => {\n  const getUniversalLocation = useGetUniversalLocation();\n  return useSyncExternalStore(\n    subscribeToLocation,\n    getUniversalLocation,\n    getUniversalLocation\n  );\n};\nvar hasInitialLocationChanged = () => initialLocationHasChanged;\n\n// src/createGroup.ts\nvar createGroup = (name, baseRoute, routes) => {\n  const baseRouteObject = parseRoute(baseRoute);\n  const output = {};\n  for (const key in routes) {\n    if (Object.prototype.hasOwnProperty.call(routes, key)) {\n      output[name + key] = concatRoutes(\n        baseRouteObject,\n        parseRoute(routes[key])\n      );\n    }\n  }\n  return output;\n};\n\n// src/matcher.ts\nvar extractFromPath = (path) => {\n  const parts = path.split(\"/\").filter(isNonEmpty);\n  const output = [];\n  let ranking = parts.length > 0 ? parts.length * 5 : 6;\n  for (const part of parts) {\n    if (isParam(part)) {\n      const param = extractParamNameUnion(part.substring(1));\n      ranking += param.union == null ? 2 : 3;\n      output.push(param);\n    } else {\n      ranking += 4;\n      output.push(encodeURIComponent(part));\n    }\n  }\n  return { ranking, path: output };\n};\nvar getMatcher = (name, route) => {\n  const parsed = parseRoute(route);\n  const isArea = parsed.path.endsWith(\"/*\");\n  const { ranking, path } = extractFromPath(\n    isArea ? parsed.path.slice(0, -2) : parsed.path\n  );\n  const matcher = {\n    isArea,\n    name,\n    // penality due to wildcard\n    ranking: isArea ? ranking - 1 : ranking,\n    path,\n    search: void 0\n  };\n  if (parsed.search !== \"\") {\n    matcher.search = {};\n    const params = new URLSearchParams(parsed.search);\n    for (const [key] of params) {\n      if (isParam(key)) {\n        const multiple = key.endsWith(\"[]\");\n        const { name: name2, union } = extractParamNameUnion(\n          key.substring(1, key.length - (multiple ? 2 : 0))\n        );\n        matcher.search[name2] = union == null ? { multiple } : { multiple, union };\n      }\n    }\n  }\n  return matcher;\n};\nvar getMatchResult = (location, matcher) => {\n  if (!matcher.isArea && location.path.length !== matcher.path.length || matcher.isArea && location.path.length < matcher.path.length) {\n    return;\n  }\n  const pathParams = {};\n  const searchParams = {};\n  for (let index = 0; index < matcher.path.length; index++) {\n    const part = location.path[index];\n    const test = matcher.path[index];\n    if (test == null) {\n      continue;\n    }\n    if (typeof test === \"string\") {\n      if (part === test) {\n        continue;\n      } else {\n        return;\n      }\n    }\n    if (part == null) {\n      return;\n    }\n    const { name, union } = test;\n    if (union == null || union.includes(part)) {\n      pathParams[name] = part;\n    } else {\n      return;\n    }\n  }\n  for (const key in matcher.search) {\n    if (Object.prototype.hasOwnProperty.call(matcher.search, key)) {\n      const part = location.search[key];\n      const test = matcher.search[key];\n      if (part == null || test == null) {\n        continue;\n      }\n      const { multiple, union } = test;\n      const parts = typeof part === \"string\" ? [part] : part;\n      const values = union == null ? parts : parts.filter((item) => union.includes(item));\n      if (multiple) {\n        searchParams[key] = values;\n        continue;\n      }\n      const value = values[0];\n      if (value != null) {\n        searchParams[key] = value;\n      }\n    }\n  }\n  return {\n    key: getRouteKey(matcher.name, pathParams, searchParams),\n    name: matcher.name,\n    params: { ...pathParams, ...searchParams }\n  };\n};\nvar match = (location, matchers) => {\n  for (const matcher of matchers) {\n    const result = getMatchResult(location, matcher);\n    if (result != null) {\n      return result;\n    }\n  }\n};\nvar matchToUrl = (matcher, params = {}) => {\n  const path = \"/\" + matcher.path.map(\n    (part) => encodeURIComponent(\n      typeof part === \"string\" ? part : String(params[part.name])\n    )\n  ).join(\"/\");\n  let search = \"\";\n  if (matcher.search != null) {\n    const object = {};\n    for (const key in params) {\n      const param = params[key];\n      const test = matcher.search[key];\n      if (param == null || test == null) {\n        continue;\n      }\n      const { union } = test;\n      if (typeof param === \"string\") {\n        if (union == null || union.includes(param)) {\n          object[key] = param;\n        }\n      } else {\n        object[key] = union == null ? param : param.filter((item) => union.includes(item));\n      }\n    }\n    search = encodeSearch(object);\n  }\n  return path + search;\n};\n\n// src/createRouter.ts\nvar createRouter = (routes, options = {}) => {\n  const { basePath = \"\" } = options;\n  const basePathObject = {\n    path: parseRoute(basePath).path,\n    search: \"\"\n    // search is not supported in basePath\n  };\n  const matchers = {};\n  const rankedMatchers = [];\n  for (const routeName in routes) {\n    if (Object.prototype.hasOwnProperty.call(routes, routeName)) {\n      const matcher = getMatcher(\n        routeName,\n        basePath !== \"\" ? concatRoutes(basePathObject, parseRoute(routes[routeName])) : routes[routeName]\n      );\n      matchers[routeName] = matcher;\n      rankedMatchers.push(matcher);\n    }\n  }\n  rankedMatchers.sort(\n    (matcherA, matcherB) => matcherB.ranking - matcherA.ranking\n  );\n  const P = {};\n  const createURLFns = {};\n  for (const matcher of rankedMatchers) {\n    const name = matcher.name;\n    P[name] = (params) => ({ name, params });\n    if (!matcher.isArea) {\n      const finiteName = name;\n      createURLFns[finiteName] = (params) => matchToUrl(matchers[finiteName], params);\n    }\n  }\n  const useRoute = (routeNames) => {\n    const matchersKey = JSON.stringify(routeNames);\n    const matchers2 = useMemo(\n      () => rankedMatchers.filter(\n        ({ name }) => routeNames.includes(name)\n      ),\n      [matchersKey]\n      // eslint-disable-line react-hooks/exhaustive-deps\n    );\n    const getUniversalLocation = useGetUniversalLocation();\n    const getMatch = () => match(getUniversalLocation(), matchers2);\n    return useSyncExternalStoreWithSelector(\n      subscribeToLocation,\n      getMatch,\n      getMatch,\n      identity,\n      areRouteEqual\n    );\n  };\n  const getRoute = (routeNames, location) => {\n    const locationObject = location != null ? decodeLocation(location) : getLocation();\n    const matchers2 = rankedMatchers.filter(\n      ({ name }) => routeNames.includes(name)\n    );\n    return match(locationObject, matchers2);\n  };\n  const push = (routeName, ...params) => pushUnsafe(matchToUrl(matchers[routeName], first(params)));\n  const replace = (routeName, ...params) => replaceUnsafe(matchToUrl(matchers[routeName], first(params)));\n  return {\n    useRoute,\n    getRoute,\n    push,\n    replace,\n    P,\n    ...createURLFns\n  };\n};\nvar useLinkProps = ({\n  href,\n  replace = false,\n  target\n}) => {\n  const hrefPath = useMemo(() => parseRoute(href).path, [href]);\n  const getUniversalLocation = useGetUniversalLocation();\n  const getPath = () => hrefPath === getUniversalLocation().raw.path;\n  const active = useSyncExternalStore(subscribeToLocation, getPath, getPath);\n  const shouldReplace = replace || active;\n  const shouldIgnoreTarget = target == null || target === \"_self\";\n  return {\n    active,\n    onClick: useCallback(\n      (event) => {\n        if (!event.defaultPrevented && shouldIgnoreTarget && // Let browser handle \"target=_blank\" etc.\n        event.button === 0 && // Ignore everything but left clicks\n        !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)) {\n          event.preventDefault();\n          if (shouldReplace) {\n            replaceUnsafe(href);\n          } else {\n            pushUnsafe(href);\n          }\n        }\n      },\n      [shouldReplace, shouldIgnoreTarget, href]\n    )\n  };\n};\n\n// src/Link.ts\nvar Link = forwardRef(\n  ({\n    onClick: baseOnClick,\n    className,\n    replace,\n    style,\n    target,\n    to,\n    activeClassName,\n    activeStyle,\n    ...props\n  }, forwardedRef) => {\n    const { active, onClick } = useLinkProps({ href: to, replace, target });\n    return createElement(\"a\", {\n      ...props,\n      ref: forwardedRef,\n      href: to,\n      onClick: (event) => {\n        baseOnClick == null ? void 0 : baseOnClick(event);\n        onClick(event);\n      },\n      target,\n      className: !active || activeClassName == null ? className : className == null ? activeClassName : `${className} ${activeClassName}`,\n      style: !active || activeStyle == null ? style : style == null ? activeStyle : { ...style, ...activeStyle }\n    });\n  }\n);\nLink.displayName = \"Link\";\nvar ServerUrlProvider = ({ children, value }) => {\n  const location = decodeLocation(value);\n  return createElement(GetUniversalLocationProvider, {\n    children,\n    value: () => location\n  });\n};\nvar useBlocker = (blocked, message) => {\n  const id = useId();\n  useEffect(() => {\n    if (blocked) {\n      return block({ id, message });\n    }\n  });\n};\nvar focusableElements = {\n  A: true,\n  INPUT: true,\n  SELECT: true,\n  TEXTAREA: true\n};\nvar useFocusReset = ({\n  route,\n  containerRef\n}) => {\n  const focusKey = route == null ? void 0 : route.key.split(\"-\")[0];\n  useEffect(() => {\n    const element = containerRef.current;\n    if (element != null && hasInitialLocationChanged()) {\n      try {\n        if (element.getAttribute(\"tabIndex\") == null && !focusableElements[element.nodeName]) {\n          element.setAttribute(\"tabIndex\", \"-1\");\n        }\n        element.focus();\n      } catch {\n      }\n    }\n  }, [containerRef, focusKey]);\n};\n\nexport { Link, ServerUrlProvider, createGroup, createRouter, decodeSearch, encodeSearch, getLocation, pushUnsafe, replaceUnsafe, subscribeToLocation, useBlocker, useFocusReset, useLinkProps, useLocation };\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map"],"names":["last","value","noop","isNonEmpty","ensureSlashPrefix","areParamsArrayEqual","arrayA","arrayB","a","index","decodeSearch","search","params","output","key","existing","NO_VALUE_PARAM_REGEXP","FINISH_BY_EQUAL_REGEXP","encodeSearch","keys","item","initialLocationHasChanged","parseRoute","route","hashIndex","cleanRoute","searchIndex","decodeLocation","input","path","parsedPath","parsedSearch","rawPath","rawSearch","stringifiedLocation","onBeforeUnload","event","createBrowserHistory","listeners","blockers","globalHistory","globalLocation","currentLocation","maybeUpdateLocation","nextLocation","searchHasChanged","prevValue","listener","url","blocker","id","history","getLocation","subscribeToLocation","pushUnsafe","replaceUnsafe","GetUniversalLocationContext","createContext","useGetUniversalLocation","useContext","useLocation","getUniversalLocation","useSyncExternalStore","useLinkProps","href","replace","target","hrefPath","useMemo","getPath","active","shouldReplace","shouldIgnoreTarget","useCallback","Link","forwardRef","baseOnClick","className","style","to","activeClassName","activeStyle","props","forwardedRef","onClick","createElement"],"mappings":"6EAMA,IAAIA,EAAQC,GAAUA,EAAMA,EAAM,OAAS,CAAC,EAExCC,EAAO,IAAM,CACjB,EACIC,EAAcF,GAAUA,IAAU,GAElCG,EAAqBH,GAAUA,EAAM,CAAC,IAAM,IAAMA,EAAQ,IAAMA,EAChEI,EAAsB,CAACC,EAAQC,IAAWD,EAAO,SAAWC,EAAO,QAAUD,EAAO,MAAM,CAACE,EAAGC,IAAUD,IAAMD,EAAOE,CAAK,CAAC,EAoC3HC,EAAgBC,GAAW,CAC7B,MAAMC,EAAS,IAAI,gBAAgBD,CAAM,EACnCE,EAAS,CAAE,EACjB,SAAW,CAACC,EAAKb,CAAK,IAAKW,EAAQ,CACjC,MAAMG,EAAWF,EAAOC,CAAG,EACvBC,GAAY,KACdF,EAAOC,CAAG,EAAI,OAAOC,GAAa,SAAW,CAACA,EAAUd,CAAK,EAAIc,EAAS,OAAOd,CAAK,EAEtFY,EAAOC,CAAG,EAAIb,CAEpB,CACE,OAAOY,CACT,EACIG,EAAwB,MACxBC,EAAyB,MACzBC,EAAgBP,GAAW,CAC7B,MAAMQ,EAAO,OAAO,KAAKR,CAAM,EAC/B,GAAIQ,EAAK,SAAW,EAClB,MAAO,GAET,MAAMP,EAAS,IAAI,gBACnBO,EAAK,KAAM,EACX,UAAWL,KAAOK,EAAM,CACtB,MAAMlB,EAAQU,EAAOG,CAAG,EACxB,GAAIb,GAAS,KAGb,GAAI,OAAOA,GAAU,SACnBW,EAAO,OAAOE,EAAKb,CAAK,MAExB,WAAWmB,KAAQnB,EACjBW,EAAO,OAAOE,EAAKM,CAAI,CAG/B,CACE,MAAMP,EAASD,EAAO,SAAQ,EAAG,QAAQI,EAAuB,GAAG,EAAE,QAAQC,EAAwB,EAAE,EACvG,OAAIJ,IAAW,GACN,GAEF,IAAMA,CACf,EAGIQ,EAA4B,GAC5BC,EAAcC,GAAU,CAC1B,MAAMC,EAAYD,EAAM,QAAQ,GAAG,EAC7BE,EAAarB,EACjBoB,EAAY,EAAID,EAAQA,EAAM,UAAU,EAAGC,CAAS,CACrD,EACKE,EAAcD,EAAW,QAAQ,GAAG,EAC1C,OAAIC,EAAc,EACT,CAAE,KAAMD,EAAY,OAAQ,EAAI,EAElC,CACL,KAAMA,EAAW,UAAU,EAAGC,CAAW,EACzC,OAAQD,EAAW,UAAUC,CAAW,CACzC,CACH,EACIC,EAAkBC,GAAU,CAC9B,MAAML,EAAQD,EAAWM,CAAK,EACxBC,EAAON,EAAM,KAAK,UAAU,CAAC,EAC7BO,EAAaD,IAAS,GAAKR,EAA4BQ,EAAK,MAAM,GAAG,EAAE,IAAI,kBAAkB,EAAIA,EAAK,MAAM,GAAG,EAAE,OAAO1B,CAAU,EAAE,IAAI,kBAAkB,EAAI,CAAE,EAChK4B,EAAeR,EAAM,SAAW,GAAKb,EAAaa,EAAM,MAAM,EAAI,CAAE,EACpES,EAAU,IAAMF,EAAW,IAAI,kBAAkB,EAAE,KAAK,GAAG,EAC3DG,EAAYf,EAAaa,CAAY,EACrCG,EAAsBF,EAAUC,EACtC,MAAO,CACL,KAAMH,EACN,OAAQC,EACR,IAAK,CACH,KAAMC,EACN,OAAQC,CACT,EACD,UAAW,CACT,OAAOC,CACb,CACG,CACH,EACIC,EAAkBC,GAAU,CAC9BA,EAAM,eAAgB,EACtBA,EAAM,YAAc,EACtB,EACIC,EAAuB,IAAM,CAC/B,MAAMC,EAA4B,IAAI,IACtC,IAAIC,EAAW,CAAE,EACjB,MAAMC,EAAgB,OAAO,QACvBC,EAAiB,OAAO,SAC9B,IAAIC,EAAkBf,EACpBc,EAAe,SAAWA,EAAe,MAC1C,EACD,MAAME,EAAsB,IAAM,CAChC,MAAMC,EAAejB,EACnBc,EAAe,SAAWA,EAAe,MAC1C,EACD,GAAIG,EAAa,SAAQ,IAAOF,EAAgB,SAAQ,EACtD,OAEFrB,EAA4B,GAC5B,MAAMwB,EAAmBD,EAAa,IAAI,SAAWF,EAAgB,IAAI,OACnE/B,EAASkC,EAAmB,CAAE,EAAGH,EAAgB,OACvD,GAAIG,GACF,UAAW/B,KAAO8B,EAAa,OAC7B,GAAI,OAAO,UAAU,eAAe,KAAKA,EAAa,OAAQ9B,CAAG,EAAG,CAClE,MAAMb,EAAQ2C,EAAa,OAAO9B,CAAG,EACrC,GAAIb,GAAS,KACX,SAEF,MAAM6C,EAAYJ,EAAgB,OAAO5B,CAAG,EACxCgC,GAAa,MAAQ,OAAOA,GAAc,UAAY,OAAO7C,GAAU,UAAY,CAACI,EAAoBJ,EAAO6C,CAAS,EAC1HnC,EAAOG,CAAG,EAAIb,EAEdU,EAAOG,CAAG,EAAIgC,CAE1B,EAGIJ,EAAkB,CAChB,KAAME,EAAa,IAAI,OAASF,EAAgB,IAAI,KAAOE,EAAa,KAAOF,EAAgB,KAC/F,OAAA/B,EACA,IAAKiC,EAAa,IAClB,SAAUA,EAAa,QACxB,EACDN,EAAU,QAASS,GAAaA,EAASL,CAAe,CAAC,CAC1D,EACD,cAAO,iBAAiB,WAAY,IAAM,CACxCC,EAAqB,CACzB,CAAG,EACM,CACL,IAAI,UAAW,CACb,OAAOD,CACR,EACD,UAAYK,IACVT,EAAU,IAAIS,CAAQ,EACf,IAAM,CACXT,EAAU,OAAOS,CAAQ,CAC1B,GAEH,KAAOC,GAAQ,CACb,MAAMC,EAAUjD,EAAKuC,CAAQ,EAC7B,GAAIU,GAAW,MAAQ,OAAO,QAAQA,EAAQ,OAAO,EAAG,CACtD,GAAI,CACFT,EAAc,UAAU,KAAM,GAAIQ,CAAG,CAC/C,MAAgB,CACNP,EAAe,OAAOO,CAAG,CACnC,CACQL,EAAqB,CAC7B,CACK,EACD,QAAUK,GAAQ,CAChB,MAAMC,EAAUjD,EAAKuC,CAAQ,GACzBU,GAAW,MAAQ,OAAO,QAAQA,EAAQ,OAAO,KACnDT,EAAc,aAAa,KAAM,GAAIQ,CAAG,EACxCL,EAAqB,EAExB,EACD,MAAQM,IACNV,EAAS,KAAKU,CAAO,EACjBV,EAAS,SAAW,GACtB,OAAO,iBAAiB,eAAgBJ,EAAgB,CACtD,QAAS,EACnB,CAAS,EAEI,IAAM,CACXI,EAAWA,EAAS,OAAO,CAAC,CAAE,GAAAW,CAAE,IAAOA,IAAOD,EAAQ,EAAE,EACpDV,EAAS,SAAW,GACtB,OAAO,oBAAoB,eAAgBJ,EAAgB,CACzD,QAAS,EACrB,CAAW,CAEJ,EAEJ,CACH,EACIgB,EAAU,OAAO,OAAW,IAAcd,EAAoB,EAAK,CACrE,SAAUV,EAAe,GAAG,EAC5B,UAAW,IAAMzB,EACjB,KAAMA,EACN,QAASA,CAEX,EACIkD,EAAc,IAAMD,EAAQ,SAC5BE,EAAsBF,EAAQ,UAC9BG,EAAaH,EAAQ,KACrBI,EAAgBJ,EAAQ,QAExBK,EAA8BC,EAAa,cAACL,CAAW,EACxBI,EAA4B,SAC/D,IAAIE,EAA0B,IAAMC,EAAU,WAACH,CAA2B,EACtEI,EAAc,IAAM,CACtB,MAAMC,EAAuBH,EAAyB,EACtD,OAAOI,EAAoB,qBACzBT,EACAQ,EACAA,CACD,CACH,EAkOIE,EAAe,CAAC,CAClB,KAAAC,EACA,QAAAC,EAAU,GACV,OAAAC,CACF,IAAM,CACJ,MAAMC,EAAWC,EAAO,QAAC,IAAM9C,EAAW0C,CAAI,EAAE,KAAM,CAACA,CAAI,CAAC,EACtDH,EAAuBH,EAAyB,EAChDW,EAAU,IAAMF,IAAaN,EAAsB,EAAC,IAAI,KACxDS,EAASR,EAAoB,qBAACT,EAAqBgB,EAASA,CAAO,EACnEE,EAAgBN,GAAWK,EAC3BE,EAAqBN,GAAU,MAAQA,IAAW,QACxD,MAAO,CACL,OAAAI,EACA,QAASG,EAAW,YACjBrC,GAAU,CACL,CAACA,EAAM,kBAAoBoC,GAC/BpC,EAAM,SAAW,GACjB,EAAEA,EAAM,SAAWA,EAAM,QAAUA,EAAM,SAAWA,EAAM,YACxDA,EAAM,eAAgB,EAClBmC,EACFhB,EAAcS,CAAI,EAElBV,EAAWU,CAAI,EAGpB,EACD,CAACO,EAAeC,EAAoBR,CAAI,CAC9C,CACG,CACH,EAGIU,EAAOC,EAAU,WACnB,CAAC,CACC,QAASC,EACT,UAAAC,EACA,QAAAZ,EACA,MAAAa,EACA,OAAAZ,EACA,GAAAa,EACA,gBAAAC,EACA,YAAAC,EACA,GAAGC,CACJ,EAAEC,IAAiB,CAClB,KAAM,CAAE,OAAAb,EAAQ,QAAAc,CAAO,EAAKrB,EAAa,CAAE,KAAMgB,EAAI,QAAAd,EAAS,OAAAC,EAAQ,EACtE,OAAOmB,EAAAA,cAAc,IAAK,CACxB,GAAGH,EACH,IAAKC,EACL,KAAMJ,EACN,QAAU3C,GAAU,CAClBwC,GAAe,MAAgBA,EAAYxC,CAAK,EAChDgD,EAAQhD,CAAK,CACd,EACD,OAAA8B,EACA,UAAW,CAACI,GAAUU,GAAmB,KAAOH,EAAYA,GAAa,KAAOG,EAAkB,GAAGH,CAAS,IAAIG,CAAe,GACjI,MAAO,CAACV,GAAUW,GAAe,KAAOH,EAAQA,GAAS,KAAOG,EAAc,CAAE,GAAGH,EAAO,GAAGG,CAAW,CAC9G,CAAK,CACL,CACA,EACAP,EAAK,YAAc","x_google_ignoreList":[0]}