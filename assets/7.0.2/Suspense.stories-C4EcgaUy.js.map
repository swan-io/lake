{"version":3,"file":"Suspense.stories-C4EcgaUy.js","sources":["../../../packages/lake/src/hooks/useAsyncDataSuspense.ts"],"sourcesContent":["import { AsyncData, Deferred } from \"@swan-io/boxed\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\nexport const useAsyncDataSuspense = <T extends AsyncData<unknown>>(asyncData: T) => {\n  // For the sake of simplicity here, we also consider `NotAsked` to be a\n  // loading state, so that Suspense is triggered immediately if the query initializes\n  // in a `useEffect` hook, leaving a component render with `NotAsked`\n  const hasResolved = useRef(asyncData.isDone());\n\n  const deferredRef = useRef(Deferred.make());\n  const [future, resolve] = deferredRef.current;\n\n  const promiseToThrow = useMemo(() => future.toPromise(), [future]);\n\n  useEffect(() => {\n    // Once the `asyncData` has been `Done` at least once, the component becomes\n    // responsible for its own loading states\n    if (asyncData.isDone()) {\n      resolve(undefined);\n      hasResolved.current = true;\n    }\n  });\n\n  if (!hasResolved.current) {\n    throw promiseToThrow;\n  }\n};\n"],"names":["useAsyncDataSuspense","asyncData","hasResolved","useRef","deferredRef","Deferred","future","resolve","promiseToThrow","useMemo","useEffect"],"mappings":"kbAGa,MAAAA,EAAsDC,GAAiB,CAIlF,MAAMC,EAAcC,EAAA,OAAOF,EAAU,OAAQ,CAAA,EAEvCG,EAAcD,EAAA,OAAOE,EAAS,KAAM,CAAA,EACpC,CAACC,EAAQC,CAAO,EAAIH,EAAY,QAEhCI,EAAiBC,EAAAA,QAAQ,IAAMH,EAAO,YAAa,CAACA,CAAM,CAAC,EAW7D,GATJI,EAAAA,UAAU,IAAM,CAGVT,EAAU,WACZM,EAAQ,MAAS,EACjBL,EAAY,QAAU,GACxB,CACD,EAEG,CAACA,EAAY,QACT,MAAAM,CAEV;;;;;;;;;;;;;;;"}