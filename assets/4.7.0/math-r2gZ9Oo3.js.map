{"version":3,"file":"math-r2gZ9Oo3.js","sources":["../../../packages/lake/src/utils/math.ts"],"sourcesContent":["import { isNotNullish, isNullish } from \"./nullish\";\n\ntype InterpolateTuple = [number, number, ...number[]];\ntype FixedLength<L extends number> = number[] & { 0: number; length: L };\n\ntype InterpolateParams<T extends InterpolateTuple> = {\n  inputRange: T;\n  outputRange: FixedLength<T[\"length\"]>;\n  clamp?: boolean;\n};\n\nconst getValue = (array: number[], index: number, name: string): number => {\n  const value = array[index];\n  if (isNullish(value)) {\n    throw new Error(`Interpolation Error: index \"${index}\" doesn't exists in ${name}`);\n  }\n  return value;\n};\n\nexport const clampValue =\n  (min: number, max: number) =>\n  (value: number): number =>\n    Math.max(Math.min(value, max), min);\n\n// Here we can disable no-non-null-assertion because this function is called in interpolate which have types checking if there is at least 2 values in range\nconst getRangeIndexes = <T extends InterpolateTuple>(range: T, value: number): [number, number] => {\n  if (value < range[0]) {\n    return [0, 1];\n  }\n\n  const maxIndex = range.length - 1;\n  for (let i = 0; i <= maxIndex; i += 1) {\n    const nextIndex = i + 1;\n    const startRange = getValue(range, i, \"range\");\n    const endRange = range[nextIndex];\n\n    if (isNotNullish(endRange) && value > startRange && value < endRange) {\n      return [i, nextIndex];\n    }\n  }\n\n  // if no values was found, it means value is upper than last range value\n  return [maxIndex - 1, maxIndex];\n};\n\n/**\n * This function is similar to `Animated.interpolate` except this one can be used with numbers\n * Whereas `Animated.interpolate` works only with animated values and return a listener, not a single value\n */\nexport const interpolate = <T extends InterpolateTuple>({\n  inputRange: input,\n  outputRange: output,\n  clamp = true,\n}: InterpolateParams<T>): ((value: number) => number) => {\n  return (value: number): number => {\n    const [startIndex, endIndex] = getRangeIndexes(input, value);\n    const inputStart = getValue(input, startIndex, \"inputRange\");\n    const inputEnd = getValue(input, endIndex, \"inputRange\");\n    const lastInput = getValue(input, input.length - 1, \"inputRange\");\n    const outputStart = getValue(output, startIndex, \"outputRange\");\n    const outputEnd = getValue(output, endIndex, \"outputRange\");\n\n    const inputRange = inputEnd - inputStart;\n    const outputRange = outputEnd - outputStart;\n\n    const valueToConvert = clamp ? clampValue(input[0], lastInput)(value) : value;\n\n    const valueWithoutOffset = valueToConvert - inputStart;\n    const outputWithoutOffset = (outputRange * valueWithoutOffset) / inputRange;\n    const outputValue = outputWithoutOffset + outputStart;\n\n    return outputValue;\n  };\n};\n\ntype ElasticParams = {\n  elasticLength?: number; // the maximum value you can reach\n  elasticStrength?: number; // higher value, maximum value reached faster\n};\n\n/**\n * This function takes as input a number from 0 to Infinity and returns a number from 0 to elasticLength\n * With an exponential curve giving a feeling of elasticity\n * This kind of function can be used to:\n *  - recreate effect like scroll bounce on iOS\n *  - limit grab smoothly with touch interaction\n */\nexport const limitElastic =\n  ({ elasticLength = 100, elasticStrength = 0.008 }: ElasticParams) =>\n  (value: number): number =>\n    elasticLength * (1 - Math.exp(-elasticStrength * value));\n"],"names":["getValue","array","index","name","value","isNullish","clampValue","min","max","getRangeIndexes","range","maxIndex","i","nextIndex","startRange","endRange","isNotNullish","interpolate","input","output","clamp","startIndex","endIndex","inputStart","inputEnd","lastInput","outputStart","outputEnd","inputRange","outputRange","valueWithoutOffset","limitElastic","elasticLength","elasticStrength"],"mappings":"+CAWA,MAAMA,EAAW,CAACC,EAAiBC,EAAeC,IAAyB,CACnE,MAAAC,EAAQH,EAAMC,CAAK,EACrB,GAAAG,EAAUD,CAAK,EACjB,MAAM,IAAI,MAAM,+BAA+BF,CAAK,uBAAuBC,CAAI,EAAE,EAE5E,OAAAC,CACT,EAEaE,EACX,CAACC,EAAaC,IACbJ,GACC,KAAK,IAAI,KAAK,IAAIA,EAAOI,CAAG,EAAGD,CAAG,EAGhCE,EAAkB,CAA6BC,EAAUN,IAAoC,CAC7F,GAAAA,EAAQM,EAAM,CAAC,EACV,MAAA,CAAC,EAAG,CAAC,EAGR,MAAAC,EAAWD,EAAM,OAAS,EAChC,QAASE,EAAI,EAAGA,GAAKD,EAAUC,GAAK,EAAG,CACrC,MAAMC,EAAYD,EAAI,EAChBE,EAAad,EAASU,EAAOE,EAAG,OAAO,EACvCG,EAAWL,EAAMG,CAAS,EAEhC,GAAIG,EAAaD,CAAQ,GAAKX,EAAQU,GAAcV,EAAQW,EACnD,MAAA,CAACH,EAAGC,CAAS,CAExB,CAGO,MAAA,CAACF,EAAW,EAAGA,CAAQ,CAChC,EAMaM,EAAc,CAA6B,CACtD,WAAYC,EACZ,YAAaC,EACb,MAAAC,EAAQ,EACV,IACUhB,GAA0B,CAChC,KAAM,CAACiB,EAAYC,CAAQ,EAAIb,EAAgBS,EAAOd,CAAK,EACrDmB,EAAavB,EAASkB,EAAOG,EAAY,YAAY,EACrDG,EAAWxB,EAASkB,EAAOI,EAAU,YAAY,EACjDG,EAAYzB,EAASkB,EAAOA,EAAM,OAAS,EAAG,YAAY,EAC1DQ,EAAc1B,EAASmB,EAAQE,EAAY,aAAa,EACxDM,EAAY3B,EAASmB,EAAQG,EAAU,aAAa,EAEpDM,EAAaJ,EAAWD,EACxBM,EAAcF,EAAYD,EAI1BI,GAFiBV,EAAQd,EAAWY,EAAM,CAAC,EAAGO,CAAS,EAAErB,CAAK,EAAIA,GAE5BmB,EAIrC,OAHsBM,EAAcC,EAAsBF,EACvBF,CAEnC,EAgBEK,EACX,CAAC,CAAE,cAAAC,EAAgB,IAAK,gBAAAC,EAAkB,IAAM,IAC/C7B,GACC4B,GAAiB,EAAI,KAAK,IAAI,CAACC,EAAkB7B,CAAK"}