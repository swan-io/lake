{"version":3,"mappings":"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","names":["styles","StyleSheet","AutocompleteSearchInput","inputRef","value","onValueChange","disabled","id","placeholder","error","emptyResultText","ListFooterComponent","shouldDisplaySuggestions","loadSuggestions","onSuggestion","onLoadError","state","setState","useState","AsyncData","lastRequest","useRef","jsx","LakeCombobox","jsxs","Fragment","match","Result","P","suggestions","Separator","item","_a","request","LakeText","colors","debounce","fn","ms","timer","args","resolve","usePlacekit","apiKey","debounceInterval","client","setClient","useEffect","__vitePreload","placekit","useMemo","PlacekitAddressSearchInput","country","language","useCallback","countries","Array","countriesWithMultipleCCA3","cca3","Option","getCCA2forCCA3","cca2Countries","Future","results","result","onSuggestionSelected","suggestion","PlacekitCityInput","cca3Codes","array","t"],"ignoreList":[],"sources":["../../../packages/lake/src/components/AutocompleteSearchInput.tsx","../../../packages/shared-business/src/hooks/usePlacekit.tsx","../../../packages/shared-business/src/components/PlacekitAddressSearchInput.tsx","../../../packages/shared-business/src/components/PlacekitCityInput.tsx"],"sourcesContent":["import { AsyncData, Future, Result } from \"@swan-io/boxed\";\nimport { MutableRefObject, ReactNode, useRef, useState } from \"react\";\nimport { StyleSheet } from \"react-native\";\nimport { P, match } from \"ts-pattern\";\nimport { colors } from \"../constants/design\";\nimport { LakeCombobox } from \"./LakeCombobox\";\nimport { LakeText } from \"./LakeText\";\nimport { Separator } from \"./Separator\";\n\nconst styles = StyleSheet.create({\n  unselectable: {\n    userSelect: \"none\",\n  },\n});\n\ntype Suggestion<T> = {\n  title: string;\n  subtitle: string;\n  value: T;\n};\n\ntype Props<T> = {\n  inputRef?: MutableRefObject<unknown>;\n  value?: string;\n  onValueChange: (value: string) => void;\n  disabled?: boolean;\n  id?: string;\n  placeholder?: string;\n  error?: string;\n  emptyResultText: string;\n  ListFooterComponent?: ReactNode;\n  shouldDisplaySuggestions?: boolean;\n  loadSuggestions?: (value: string) => Future<Result<Suggestion<T>[], unknown>>;\n  onSuggestion: (suggestion: Suggestion<T>) => void;\n  onLoadError?: (error: unknown) => void;\n};\n\ntype State<T> = AsyncData<Result<Suggestion<T>[], unknown>>;\n\nexport const AutocompleteSearchInput = <T,>({\n  inputRef,\n  value,\n  onValueChange,\n  disabled,\n  id,\n  placeholder,\n  error,\n  emptyResultText,\n  ListFooterComponent,\n  shouldDisplaySuggestions = true,\n  loadSuggestions,\n  onSuggestion,\n  onLoadError,\n}: Props<T>) => {\n  const [state, setState] = useState<State<T>>(AsyncData.NotAsked());\n  const lastRequest = useRef<Future<Result<Suggestion<T>[], unknown>>>();\n\n  return (\n    <LakeCombobox<Suggestion<T>>\n      inputRef={inputRef}\n      id={id}\n      placeholder={placeholder}\n      value={value ?? \"\"}\n      items={state}\n      icon={loadSuggestions != null ? \"search-filled\" : undefined}\n      disabled={disabled}\n      error={error}\n      ListFooterComponent={\n        ListFooterComponent != null && (\n          <>\n            {match(state)\n              .with(AsyncData.P.Done(Result.P.Ok(P.select())), suggestions =>\n                suggestions.length > 0 ? <Separator /> : null,\n              )\n              .otherwise(() => null)}\n\n            {ListFooterComponent}\n          </>\n        )\n      }\n      onSelectItem={item => {\n        onSuggestion(item);\n      }}\n      onValueChange={value => {\n        lastRequest.current?.cancel(); // cancel previous request to avoid race condition\n        lastRequest.current = undefined; // avoid to cancel twice the same request\n\n        onValueChange(value);\n\n        if (value.length <= 3 || !shouldDisplaySuggestions) {\n          return setState(AsyncData.NotAsked());\n        }\n\n        if (loadSuggestions != null) {\n          setState(AsyncData.Loading());\n\n          const request = loadSuggestions(value);\n          lastRequest.current = request;\n\n          if (onLoadError != null) {\n            request.tapError(onLoadError);\n          }\n          request.onResolve(value => setState(AsyncData.Done(value)));\n        }\n      }}\n      keyExtractor={item => `${item.title} ${item.subtitle}`}\n      emptyResultText={emptyResultText}\n      renderItem={item => (\n        <>\n          <LakeText numberOfLines={1} style={styles.unselectable} color={colors.gray[900]}>\n            {item.title}\n          </LakeText>\n\n          <LakeText numberOfLines={1} style={styles.unselectable} variant=\"smallRegular\">\n            {item.subtitle}\n          </LakeText>\n        </>\n      )}\n    />\n  );\n};\n","import type { PKClient } from \"@placekit/client-js/lite\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nconst debounce = <A extends unknown[], R>(fn: (...args: A) => Promise<R>, ms: number) => {\n  let timer: NodeJS.Timeout | undefined;\n\n  return (...args: A) => {\n    clearTimeout(timer);\n\n    return new Promise<R>(resolve => {\n      timer = setTimeout(() => resolve(fn(...args)), ms);\n    });\n  };\n};\n\nexport const usePlacekit = ({\n  apiKey,\n  debounceInterval = 1000,\n}: {\n  apiKey?: string;\n  debounceInterval?: number;\n}) => {\n  const [client, setClient] = useState<PKClient>();\n\n  useEffect(() => {\n    if (apiKey != null) {\n      void import(\"@placekit/client-js/lite\").then(({ default: placekit }) => {\n        setClient(placekit(apiKey));\n      });\n    }\n  }, [apiKey]);\n\n  return useMemo<PKClient | undefined>(() => {\n    if (client != null) {\n      return {\n        ...client,\n        search: debounce(client.search, debounceInterval),\n        reverse: debounce(client.reverse, debounceInterval),\n      };\n    }\n  }, [client, debounceInterval]);\n};\n","import { PKResult } from \"@placekit/client-js/.\";\nimport { Array, Future, Option, Result } from \"@swan-io/boxed\";\nimport { AutocompleteSearchInput } from \"@swan-io/lake/src/components/AutocompleteSearchInput\";\nimport {\n  CountryCCA3,\n  countriesWithMultipleCCA3,\n  getCCA2forCCA3,\n} from \"@swan-io/shared-business/src/constants/countries\";\nimport { MutableRefObject, useCallback } from \"react\";\nimport { StyleProp, ViewStyle } from \"react-native\";\nimport { usePlacekit } from \"../hooks/usePlacekit\";\n\ntype Suggestion = {\n  title: string;\n  subtitle: string;\n  value: PKResult;\n};\n\nexport type AddressDetail = {\n  completeAddress: string;\n  city: string;\n  postalCode?: string;\n};\n\ntype Props = {\n  inputRef?: MutableRefObject<unknown>;\n  id?: string;\n  country: CountryCCA3; // cca3 country\n  disabled?: boolean;\n  error?: string;\n  onSuggestion?: (suggestion: AddressDetail) => void;\n  onValueChange: (value: string) => void;\n  style?: StyleProp<ViewStyle>;\n  value?: string;\n  language: \"en\" | \"es\" | \"de\" | \"fi\" | \"fr\" | \"it\" | \"nl\" | \"pt\";\n  placeholder: string;\n  shouldDisplaySuggestions?: boolean;\n  emptyResultText: string;\n  apiKey?: string;\n};\n\nexport const PlacekitAddressSearchInput = ({\n  inputRef,\n  id,\n  country,\n  disabled,\n  error,\n  value,\n  onValueChange,\n  onSuggestion,\n  language,\n  placeholder,\n  shouldDisplaySuggestions = true,\n  emptyResultText,\n  apiKey,\n}: Props) => {\n  const placekit = usePlacekit({ apiKey });\n\n  const loadSuggestions = useCallback(\n    (value: string): Future<Result<Suggestion[], unknown>> => {\n      if (placekit != null) {\n        const countries = Array.filterMap(countriesWithMultipleCCA3[country] ?? [country], cca3 =>\n          Option.fromNullable(getCCA2forCCA3(cca3)),\n        );\n        const cca2Countries = countries.length === 0 ? Option.None() : Option.Some(countries);\n\n        return Future.fromPromise(\n          placekit.search(value, {\n            types: [\"street\"],\n            language,\n            countries: cca2Countries.toUndefined(),\n          }),\n        ).mapOk(\n          ({ results }) =>\n            results.map(result => ({\n              title: result.name,\n              subtitle: result.city,\n              value: result,\n            })),\n          true,\n        );\n      }\n\n      return Future.value(Result.Ok([] as Suggestion[]));\n    },\n    [placekit, country, language],\n  );\n\n  const onSuggestionSelected = useCallback(\n    (suggestion: Suggestion) => {\n      onSuggestion?.({\n        completeAddress: suggestion.value.name,\n        postalCode: suggestion.value.zipcode[0],\n        city: suggestion.value.city,\n      });\n    },\n    [onSuggestion],\n  );\n\n  return (\n    <AutocompleteSearchInput\n      inputRef={inputRef}\n      value={value}\n      onValueChange={onValueChange}\n      disabled={disabled}\n      id={id}\n      placeholder={placeholder}\n      error={error}\n      emptyResultText={emptyResultText}\n      shouldDisplaySuggestions={shouldDisplaySuggestions}\n      loadSuggestions={placekit != null ? loadSuggestions : undefined}\n      onSuggestion={onSuggestionSelected}\n    />\n  );\n};\n","import { PKResult } from \"@placekit/client-js/.\";\nimport { Array, Future, Option, Result } from \"@swan-io/boxed\";\nimport { AutocompleteSearchInput } from \"@swan-io/lake/src/components/AutocompleteSearchInput\";\nimport { useCallback } from \"react\";\nimport { CountryCCA3, countriesWithMultipleCCA3, getCCA2forCCA3 } from \"../constants/countries\";\nimport { usePlacekit } from \"../hooks/usePlacekit\";\nimport { t } from \"../utils/i18n\";\n\ntype Suggestion = {\n  title: string;\n  subtitle: string;\n  value: PKResult;\n};\n\nexport type CityDetail = {\n  city: string;\n  postalCode?: string;\n};\n\ntype Props = {\n  value: string;\n  onValueChange: (value: string) => void;\n  country?: CountryCCA3;\n  disabled?: boolean;\n  error?: string;\n  id?: string;\n  placeholder?: string;\n  onSuggestion?: (place: CityDetail) => void;\n  onLoadError: (error: unknown) => void;\n  apiKey?: string;\n};\n\nexport const PlacekitCityInput = ({\n  value,\n  onValueChange,\n  country,\n  disabled,\n  placeholder,\n  id,\n  error,\n  onSuggestion,\n  onLoadError,\n  apiKey,\n}: Props) => {\n  const placekit = usePlacekit({ apiKey });\n\n  const loadSuggestions = useCallback(\n    (value: string): Future<Result<Suggestion[], unknown>> => {\n      if (placekit != null) {\n        const countries = Option.fromNullable(country)\n          .map(country => countriesWithMultipleCCA3[country] ?? [country])\n          .map(cca3Codes =>\n            Array.filterMap(cca3Codes, cca3 => Option.fromNullable(getCCA2forCCA3(cca3))),\n          )\n          .flatMap(array => (array.length === 0 ? Option.None() : Option.Some(array)));\n\n        return Future.fromPromise(\n          placekit.search(value, {\n            types: [\"city\"],\n            countries: countries.toUndefined(),\n          }),\n        ).mapOk(\n          ({ results }) =>\n            results.map(result => ({\n              title: result.name,\n              subtitle: result.city,\n              value: result,\n            })),\n          true,\n        );\n      }\n\n      return Future.value(Result.Ok([] as Suggestion[]));\n    },\n    [placekit, country],\n  );\n\n  const onSuggestionSelected = useCallback(\n    (suggestion: Suggestion) => {\n      onSuggestion?.({\n        city: suggestion.value.city,\n        postalCode: suggestion.value.zipcode[0],\n      });\n    },\n    [onSuggestion],\n  );\n\n  return (\n    <AutocompleteSearchInput\n      value={value}\n      onValueChange={onValueChange}\n      disabled={disabled}\n      id={id}\n      placeholder={placeholder}\n      error={error}\n      emptyResultText={t(\"common.noResult\")}\n      loadSuggestions={placekit != null ? loadSuggestions : undefined}\n      onSuggestion={onSuggestionSelected}\n      onLoadError={onLoadError}\n    />\n  );\n};\n"],"file":"assets/8.9.2/Combobox.stories-BQusmBtR.js"}