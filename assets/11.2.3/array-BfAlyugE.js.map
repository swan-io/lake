{"version":3,"file":"array-BfAlyugE.js","sources":["../../../packages/lake/src/utils/array.ts"],"sourcesContent":["export const sortBy = <K extends string, T extends Record<K, unknown>>(\n  array: T[],\n  keys: K[],\n): T[] => {\n  return [...array].sort((a, b) => {\n    let index = -1;\n    while (++index < keys.length) {\n      const key = keys[index];\n      if (key == undefined) {\n        return 0;\n      }\n      if (b[key] === a[key]) {\n        continue;\n      }\n      return b[key] > a[key] ? -1 : 1;\n    }\n    return 0;\n  });\n};\n\nexport const first = <T>(array: readonly T[]): T | undefined => {\n  return array[0];\n};\n\nexport const last = <T>(array: readonly T[]): T | undefined => {\n  return array[array.length - 1];\n};\n\nexport const partition = <T>(array: T[], predicate: (value: T) => boolean): [T[], T[]] => {\n  const truthy = [];\n  const falsy = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      truthy.push(value);\n    } else {\n      falsy.push(value);\n    }\n  }\n  return [truthy, falsy];\n};\n\nexport const sortedIndexOf = <T>(array: T[], value: T) => {\n  let startIndex = 0;\n  let endIndex = array.length;\n\n  while (true) {\n    const searchIndex = startIndex + Math.round((endIndex - startIndex) / 2);\n\n    const item = array[searchIndex];\n\n    if (searchIndex === endIndex || searchIndex === startIndex) {\n      if (item === value) {\n        return startIndex;\n      }\n      return -1;\n    }\n\n    if (item === value) {\n      return searchIndex;\n    }\n\n    if (item != null && value != null) {\n      if (item > value) {\n        endIndex = searchIndex;\n        continue;\n      }\n      if (item < value) {\n        startIndex = searchIndex;\n        continue;\n      }\n    }\n  }\n};\n\nexport const groupBy = <T, K extends string>(\n  array: T[],\n  getGroupName: (item: T) => K,\n): Partial<Record<K, T[]>> => {\n  const grouped: Partial<Record<K, T[]>> = {};\n  array.forEach(item => {\n    const groupName = getGroupName(item);\n    grouped[groupName] = [...(grouped[groupName] ?? []), item];\n  });\n  return grouped;\n};\n\nexport const intersection = <T>(arrayA: ReadonlyArray<T>, arrayB: ReadonlyArray<T>) => {\n  const toKeep = new Set(arrayB);\n  return arrayA.filter(item => toKeep.has(item));\n};\n"],"names":["first","array","last","groupBy","getGroupName","grouped","item","groupName","intersection","arrayA","arrayB","toKeep"],"mappings":"AAoBa,MAAAA,EAAYC,GAChBA,EAAM,CAAC,EAGHC,EAAWD,GACfA,EAAMA,EAAM,OAAS,CAAC,EAiDlBE,EAAU,CACrBF,EACAG,IAC4B,CAC5B,MAAMC,EAAmC,CAAC,EAC1C,OAAAJ,EAAM,QAAgBK,GAAA,CACd,MAAAC,EAAYH,EAAaE,CAAI,EAC3BD,EAAAE,CAAS,EAAI,CAAC,GAAIF,EAAQE,CAAS,GAAK,CAAC,EAAID,CAAI,CAAA,CAC1D,EACMD,CACT,EAEaG,EAAe,CAAIC,EAA0BC,IAA6B,CAC/E,MAAAC,EAAS,IAAI,IAAID,CAAM,EAC7B,OAAOD,EAAO,OAAOH,GAAQK,EAAO,IAAIL,CAAI,CAAC,CAC/C"}