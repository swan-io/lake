{"version":3,"file":"array-_tkD71ox.js","sources":["../../../packages/lake/src/utils/array.ts"],"sourcesContent":["export const sortBy = <K extends string, T extends Record<K, unknown>>(\n  array: T[],\n  keys: K[],\n): T[] => {\n  return [...array].sort((a, b) => {\n    let index = -1;\n    while (++index < keys.length) {\n      const key = keys[index];\n      if (key == undefined) {\n        return 0;\n      }\n      if (b[key] === a[key]) {\n        continue;\n      }\n      return b[key] > a[key] ? -1 : 1;\n    }\n    return 0;\n  });\n};\n\nexport const first = <T>(array: readonly T[]): T | undefined => {\n  return array[0];\n};\n\nexport const last = <T>(array: readonly T[]): T | undefined => {\n  return array[array.length - 1];\n};\n\nexport const partition = <T>(array: T[], predicate: (value: T) => boolean): [T[], T[]] => {\n  const truthy = [];\n  const falsy = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      truthy.push(value);\n    } else {\n      falsy.push(value);\n    }\n  }\n  return [truthy, falsy];\n};\n\nexport const sortedIndexOf = <T>(array: T[], value: T) => {\n  let startIndex = 0;\n  let endIndex = array.length;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const searchIndex = startIndex + Math.round((endIndex - startIndex) / 2);\n\n    const item = array[searchIndex];\n\n    if (searchIndex === endIndex || searchIndex === startIndex) {\n      if (item === value) {\n        return startIndex;\n      }\n      return -1;\n    }\n\n    if (item === value) {\n      return searchIndex;\n    }\n\n    if (item != null && value != null) {\n      if (item > value) {\n        endIndex = searchIndex;\n        continue;\n      }\n      if (item < value) {\n        startIndex = searchIndex;\n        continue;\n      }\n    }\n  }\n};\n\nexport const groupBy = <T, K extends string>(\n  array: T[],\n  getGroupName: (item: T) => K,\n): Partial<Record<K, T[]>> => {\n  const grouped: Partial<Record<K, T[]>> = {};\n  array.forEach(item => {\n    const groupName = getGroupName(item);\n    grouped[groupName] = [...(grouped[groupName] ?? []), item];\n  });\n  return grouped;\n};\n\nexport const intersection = <T>(arrayA: ReadonlyArray<T>, arrayB: ReadonlyArray<T>) => {\n  const toKeep = new Set(arrayB);\n  return arrayA.filter(item => toKeep.has(item));\n};\n"],"names":["first","array","last","sortedIndexOf","value","startIndex","endIndex","searchIndex","item","groupBy","getGroupName","grouped","groupName","intersection","arrayA","arrayB","toKeep"],"mappings":"AAoBa,MAAAA,EAAYC,GAChBA,EAAM,CAAC,EAGHC,EAAWD,GACfA,EAAMA,EAAM,OAAS,CAAC,EAgBlBE,EAAgB,CAAIF,EAAYG,IAAa,CACxD,IAAIC,EAAa,EACbC,EAAWL,EAAM,OAGrB,OAAa,CACX,MAAMM,EAAcF,EAAa,KAAK,OAAOC,EAAWD,GAAc,CAAC,EAEjEG,EAAOP,EAAMM,CAAW,EAE1B,GAAAA,IAAgBD,GAAYC,IAAgBF,EAC9C,OAAIG,IAASJ,EACJC,EAEF,GAGT,GAAIG,IAASJ,EACJ,OAAAG,EAGL,GAAAC,GAAQ,MAAQJ,GAAS,KAAM,CACjC,GAAII,EAAOJ,EAAO,CACLE,EAAAC,EACX,QACF,CACA,GAAIC,EAAOJ,EAAO,CACHC,EAAAE,EACb,QACF,CACF,CACF,CACF,EAEaE,EAAU,CACrBR,EACAS,IAC4B,CAC5B,MAAMC,EAAmC,CAAA,EACzC,OAAAV,EAAM,QAAgBO,GAAA,CACd,MAAAI,EAAYF,EAAaF,CAAI,EAC3BG,EAAAC,CAAS,EAAI,CAAC,GAAID,EAAQC,CAAS,GAAK,CAAA,EAAKJ,CAAI,CAAA,CAC1D,EACMG,CACT,EAEaE,EAAe,CAAIC,EAA0BC,IAA6B,CAC/E,MAAAC,EAAS,IAAI,IAAID,CAAM,EAC7B,OAAOD,EAAO,OAAON,GAAQQ,EAAO,IAAIR,CAAI,CAAC,CAC/C"}