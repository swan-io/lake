{"version":3,"file":"FocusTrap-0f8cef47.js","sources":["../../../packages/lake/src/hooks/useInterval.ts","../../../packages/lake/src/hooks/useOutsideClick.ts","../../../packages/lake/src/components/FocusTrap.tsx"],"sourcesContent":["import { useEffect, useRef } from \"react\";\n\nexport const useInterval = (handler: (id: number) => void, timeout: number) => {\n  const handlerRef = useRef(handler);\n\n  useEffect(() => {\n    handlerRef.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const id = window.setInterval(() => handlerRef.current(id), timeout);\n    return () => window.clearInterval(id);\n  }, [timeout]);\n};\n","import { RefObject, useCallback, useEffect, useRef } from \"react\";\nimport { isNotNullish, isNullish } from \"../utils/nullish\";\n\ntype Params = {\n  containerRef: RefObject<unknown>;\n  onClickOutside?: (event: MouseEvent | TouchEvent) => void;\n  // The following prop is necessary for the cases where the user clicks on a focusable element\n  // when leaving a popover, in order to prevent the focus from going back to the pressable that\n  // initiated the layer to pop\n  onFocusOutside?: (event: FocusEvent) => void;\n};\n\nexport const useOutsideClick = ({ containerRef, onClickOutside, onFocusOutside }: Params) => {\n  const hasTouchStartedRef = useRef(false);\n\n  const isTargetInside = useCallback(\n    (event: MouseEvent | TouchEvent | FocusEvent) => {\n      const target = event.target as Element;\n      // NOTE: Let's be careful with the `instanceof` check if we're ever to render a portal to another window\n      return (\n        isNotNullish(containerRef.current) &&\n        containerRef.current instanceof HTMLElement &&\n        containerRef.current.contains(target)\n      );\n    },\n    [containerRef],\n  );\n\n  useEffect(() => {\n    if (isNullish(onClickOutside)) {\n      return;\n    }\n\n    const onTouchStart = (event: MouseEvent | TouchEvent) => {\n      if (!isTargetInside(event)) {\n        hasTouchStartedRef.current = true;\n      }\n    };\n\n    const onTouchEnd = (event: MouseEvent | TouchEvent) => {\n      if (!isTargetInside(event) && hasTouchStartedRef.current) {\n        onClickOutside?.(event);\n      }\n\n      hasTouchStartedRef.current = false;\n    };\n\n    document.addEventListener(\"mousedown\", onTouchStart, true);\n    document.addEventListener(\"mouseup\", onTouchEnd, true);\n    document.addEventListener(\"touchstart\", onTouchStart, true);\n    document.addEventListener(\"touchend\", onTouchEnd, true);\n\n    return () => {\n      document.removeEventListener(\"mousedown\", onTouchStart, true);\n      document.removeEventListener(\"mouseup\", onTouchEnd, true);\n      document.removeEventListener(\"touchstart\", onTouchStart, true);\n      document.removeEventListener(\"touchend\", onTouchEnd, true);\n    };\n  }, [isTargetInside, onClickOutside]);\n\n  useEffect(() => {\n    if (isNullish(onFocusOutside)) {\n      return;\n    }\n\n    const onFocusIn = (event: FocusEvent) => {\n      if (!isTargetInside(event)) {\n        onFocusOutside?.(event);\n      }\n    };\n\n    // We use the `focusin` event so that we can intercept during the capturing phase\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/focusin_event\n    document.addEventListener(\"focusin\", onFocusIn, true);\n\n    return () => {\n      document.removeEventListener(\"focusin\", onFocusIn, true);\n    };\n  }, [isTargetInside, onFocusOutside]);\n};\n","import {\n  forwardRef,\n  ReactNode,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\";\nimport { NativeSyntheticEvent, StyleProp, View, ViewStyle } from \"react-native\";\nimport { match } from \"ts-pattern\";\nimport { useInterval } from \"../hooks/useInterval\";\nimport { useOutsideClick } from \"../hooks/useOutsideClick\";\nimport { getFocusableElements } from \"../utils/a11y\";\nimport { first, last } from \"../utils/array\";\nimport { isNotNullish } from \"../utils/nullish\";\n\ntype Props = {\n  autoFocus: boolean;\n  children: ReactNode;\n  focusLock: boolean;\n  onClickOutside?: (event: TouchEvent | MouseEvent) => void;\n  onEscapeKey?: () => void;\n  returnFocus: boolean;\n  style?: StyleProp<ViewStyle>;\n};\n\nexport type FocusTrapRef = {\n  setInitiallyFocusedElement: (element: HTMLElement) => void;\n};\n\nlet escapeListenerCount = 0;\n\nexport const FocusTrap = forwardRef<FocusTrapRef, Props>(\n  (\n    { children, focusLock, onClickOutside, onEscapeKey, returnFocus, style, autoFocus }: Props,\n    ref,\n  ) => {\n    const containerRef = useRef<View | null>(null);\n    const previouslyFocusedRef = useRef<HTMLElement | null>(null);\n    const hasFocusedOutside = useRef(false);\n\n    useImperativeHandle(ref, () => ({\n      setInitiallyFocusedElement: element => (previouslyFocusedRef.current = element),\n    }));\n\n    const [initialEscapeListenerCount] = useState(escapeListenerCount);\n\n    useEffect(() => {\n      ++escapeListenerCount;\n      return () => {\n        --escapeListenerCount;\n      };\n    });\n\n    // The reason we're listening to the capturing phase instead of the bubbling one is that React Native Web\n    // uses a static preventDefault in its TextInput implementation, which we cannot control.\n    // Listening to the bubbling phase catches the event before RNW has the opportunity to block.\n    const onKeyDownCapture = useCallback(\n      ({ nativeEvent }: NativeSyntheticEvent<React.KeyboardEvent>) => {\n        match(nativeEvent.key)\n          .with(\"Escape\", () => {\n            if (escapeListenerCount === initialEscapeListenerCount + 1) {\n              onEscapeKey?.();\n            }\n          })\n          .with(\"Tab\", () => {\n            if (!focusLock) {\n              return;\n            }\n\n            const trapElement = containerRef.current as unknown as HTMLElement;\n\n            if (isNotNullish(trapElement)) {\n              const target = nativeEvent.target;\n              const focusableElements = getFocusableElements(trapElement);\n              const firstFocusableElement = first(focusableElements);\n              const lastFocusableElement = last(focusableElements);\n\n              if (target === firstFocusableElement && nativeEvent.shiftKey) {\n                nativeEvent.preventDefault();\n                lastFocusableElement?.focus();\n              }\n\n              if (target === lastFocusableElement && !nativeEvent.shiftKey) {\n                nativeEvent.preventDefault();\n                firstFocusableElement?.focus();\n              }\n            }\n          })\n          .otherwise(() => {});\n      },\n      [focusLock, onEscapeKey, initialEscapeListenerCount],\n    );\n\n    useEffect(() => {\n      if (returnFocus) {\n        previouslyFocusedRef.current = document.activeElement as HTMLElement;\n\n        return () => {\n          if (!hasFocusedOutside.current) {\n            previouslyFocusedRef.current?.focus();\n          }\n        };\n      }\n    }, [returnFocus]);\n\n    useInterval(id => {\n      if (autoFocus) {\n        const trapElement = containerRef.current as unknown as HTMLElement;\n\n        if (isNotNullish(trapElement)) {\n          if (trapElement.offsetWidth === 0) {\n            return;\n          }\n\n          const focusableElements = getFocusableElements(trapElement);\n          const firstFocusableElement = first(focusableElements);\n\n          firstFocusableElement?.focus();\n          window.clearInterval(id);\n        }\n      }\n    }, 16);\n\n    const onFocusOutside = useCallback(() => {\n      hasFocusedOutside.current = true;\n    }, []);\n\n    useOutsideClick({\n      containerRef,\n      onClickOutside,\n      onFocusOutside,\n    });\n\n    return (\n      <View ref={containerRef} onKeyDownCapture={onKeyDownCapture} style={style}>\n        {children}\n      </View>\n    );\n  },\n);\n"],"names":["useInterval","handler","timeout","handlerRef","useRef","useEffect","id","useOutsideClick","containerRef","onClickOutside","onFocusOutside","hasTouchStartedRef","isTargetInside","useCallback","event","target","isNotNullish","isNullish","onTouchStart","onTouchEnd","onFocusIn","escapeListenerCount","FocusTrap","forwardRef","children","focusLock","onEscapeKey","returnFocus","style","autoFocus","ref","previouslyFocusedRef","hasFocusedOutside","useImperativeHandle","element","initialEscapeListenerCount","useState","onKeyDownCapture","nativeEvent","match","trapElement","focusableElements","getFocusableElements","firstFocusableElement","first","lastFocusableElement","last","_a","jsx","View"],"mappings":"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"}