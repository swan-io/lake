{"version":3,"file":"TimePicker.stories-SD5LfR_g.js","sources":["../../../packages/lake/src/components/TimePicker.tsx"],"sourcesContent":["import { AsyncData, Option, Result } from \"@swan-io/boxed\";\nimport { useMemo } from \"react\";\nimport { StyleSheet, View } from \"react-native\";\nimport { Rifm } from \"rifm\";\nimport { colors } from \"../constants/design\";\nimport { noop } from \"../utils/function\";\nimport { isNotNullishOrEmpty, isNullish } from \"../utils/nullish\";\nimport { getRifmProps } from \"../utils/rifm\";\nimport { Box } from \"./Box\";\nimport { Fill } from \"./Fill\";\nimport { Icon } from \"./Icon\";\nimport { LakeCombobox } from \"./LakeCombobox\";\nimport { LakeLabel } from \"./LakeLabel\";\nimport { LakeText } from \"./LakeText\";\nimport { Space } from \"./Space\";\n\nconst styles = StyleSheet.create({\n  label: {\n    flex: 1,\n  },\n  arrowContainer: {\n    height: 40, // input height\n  },\n});\n\ntype Time = {\n  hour: number;\n  minute: number;\n};\n\nconst DEFAULT_START_TIME: Time = { hour: 0, minute: 0 };\nconst DEFAULT_END_TIME: Time = { hour: 23, minute: 59 };\nconst DEFAULT_INTERVAL_IN_MINUTES = 15;\n\nconst rifmTimeProps = getRifmProps({\n  accept: \"numeric\",\n  charMap: { 2: \":\" },\n  maxLength: 4,\n});\n\nexport const parseTime = (time: string): Option<Time> => {\n  const [hours, minutes] = time.split(\":\").map(Number);\n\n  if (isNullish(hours) || isNaN(hours) || isNullish(minutes) || isNaN(minutes)) {\n    return Option.None();\n  }\n\n  return Option.Some({ hour: hours, minute: minutes });\n};\n\nexport const parseTimeRange = (value: {\n  start?: string;\n  end?: string;\n}): { start: Option<Time>; end: Option<Time> } => {\n  const start = isNotNullishOrEmpty(value.start) ? parseTime(value.start) : Option.None();\n  const end = isNotNullishOrEmpty(value.end) ? parseTime(value.end) : Option.None();\n\n  return { start, end };\n};\n\nconst parseTypingHours = (time: string): Option<number> => {\n  const [hours, minutes] = time.split(\":\");\n\n  if (isNullish(hours) || hours?.length !== 2 || isNotNullishOrEmpty(minutes)) {\n    return Option.None();\n  }\n\n  const parsedHours = Number(hours);\n\n  if (parsedHours < 0 || parsedHours > 23) {\n    return Option.None();\n  }\n\n  if (isNaN(parsedHours)) {\n    return Option.None();\n  }\n\n  return Option.Some(parsedHours);\n};\n\nconst stringifyTime = (time: Time): string => {\n  return `${time.hour.toString().padStart(2, \"0\")}:${time.minute.toString().padStart(2, \"0\")}`;\n};\n\nconst timeToMinutes = (time: Time): number => {\n  return time.hour * 60 + time.minute;\n};\n\nconst minutesToTime = (minutes: number): Time => {\n  return {\n    hour: Math.floor(minutes / 60),\n    minute: minutes % 60,\n  };\n};\n\nconst addMinutes = (time: Time, minutes: number): Time => {\n  return minutesToTime(timeToMinutes(time) + minutes);\n};\n\nconst floorTime = (time: Time, intervalInMinutes: number): Time => {\n  const minutes = timeToMinutes(time);\n  const flooredMinutes = Math.floor(minutes / intervalInMinutes) * intervalInMinutes;\n\n  return minutesToTime(flooredMinutes);\n};\n\nexport const validateTime = (time: Time): boolean => {\n  return time.hour >= 0 && time.hour <= 23 && time.minute >= 0 && time.minute <= 59;\n};\n\nconst isTimeBefore = (time1: Time, time2: Time): boolean => {\n  return timeToMinutes(time1) < timeToMinutes(time2);\n};\n\nexport const validateTimeRange = (range: { start: Option<Time>; end: Option<Time> }): boolean => {\n  if (range.start.isNone() || range.end.isNone()) {\n    return true;\n  }\n\n  return isTimeBefore(range.start.value, range.end.value);\n};\n\nconst minTime = (...times: Time[]): Time => {\n  const timesInMinutes = times.map(timeToMinutes);\n  const minTimeInMinutes = Math.min(...timesInMinutes);\n  return minutesToTime(minTimeInMinutes);\n};\n\nconst maxTime = (...times: Time[]): Time => {\n  const timesInMinutes = times.map(timeToMinutes);\n  const maxTimeInMinutes = Math.max(...timesInMinutes);\n  return minutesToTime(maxTimeInMinutes);\n};\n\nconst generateTimeList = (start: Time, end: Time, intervalInMinutes: number): Time[] => {\n  const startMinutes = timeToMinutes(start);\n  const endMinutes = timeToMinutes(end);\n\n  const timeList = [];\n  for (let i = startMinutes; i <= endMinutes; i += intervalInMinutes) {\n    const time = minutesToTime(i);\n    timeList.push(time);\n  }\n\n  return timeList;\n};\n\nconst formatTimeDuration = (time: Time, minutesLabel: string, hoursLabel: string): string => {\n  if (time.hour === 0) {\n    return `${time.minute} ${minutesLabel}`;\n  }\n\n  if (time.minute === 0) {\n    return `${time.hour} ${hoursLabel}`;\n  }\n\n  return `${time.hour} ${hoursLabel} ${time.minute} ${minutesLabel}`;\n};\n\nexport type TimePickerProps = {\n  value?: string;\n  onChangeText: (value: string) => void;\n  suggestionStart?: Time;\n  suggestionEnd?: Time;\n  intervalInMinutes?: number;\n  nbMaxSuggestions?: number;\n  suggestionSuffix?: (option: Time) => string;\n  readOnly?: boolean;\n  disabled?: boolean;\n  error?: string;\n  hideErrors?: boolean;\n  noSuggestionLabel: string;\n};\n\nexport const TimePicker = ({\n  value,\n  onChangeText,\n  suggestionStart = DEFAULT_START_TIME,\n  suggestionEnd = DEFAULT_END_TIME,\n  intervalInMinutes = DEFAULT_INTERVAL_IN_MINUTES,\n  nbMaxSuggestions,\n  suggestionSuffix,\n  readOnly,\n  disabled,\n  error,\n  hideErrors,\n  noSuggestionLabel,\n}: TimePickerProps) => {\n  const typingHour = parseTypingHours(value ?? \"\");\n\n  const optionsInterval: [Time, Time] = useMemo(\n    () =>\n      typingHour.match({\n        Some: hour => [\n          maxTime({ hour, minute: 0 }, suggestionStart),\n          minTime({ hour, minute: 59 }, suggestionEnd),\n        ],\n        None: () => [suggestionStart, suggestionEnd],\n      }),\n    [typingHour, suggestionStart, suggestionEnd],\n  );\n\n  const options = useMemo(\n    () =>\n      generateTimeList(optionsInterval[0], optionsInterval[1], intervalInMinutes).slice(\n        0,\n        nbMaxSuggestions,\n      ),\n    [optionsInterval, intervalInMinutes, nbMaxSuggestions],\n  );\n\n  const items = useMemo(() => AsyncData.Done(Result.Ok(options)), [options]);\n\n  return (\n    <Rifm value={value ?? \"\"} onChange={onChangeText} {...rifmTimeProps}>\n      {({ value, onChange }) => (\n        <LakeCombobox\n          keyExtractor={stringifyTime}\n          placeholder=\"HH:MM\"\n          value={value}\n          items={items}\n          itemHeight={40}\n          nbItemsDisplayed={4.5}\n          renderItem={item => {\n            const text = stringifyTime(item);\n            const selected = text === value;\n            const suffix = suggestionSuffix?.(item);\n            const label = isNotNullishOrEmpty(suffix) ? `${text} ${suffix}` : text;\n\n            return (\n              <Box direction=\"row\" alignItems=\"center\">\n                <LakeText\n                  color={selected ? colors.gray[700] : colors.gray[900]}\n                  variant={selected ? \"smallRegular\" : \"medium\"}\n                >\n                  {label}\n                </LakeText>\n\n                <Fill minWidth={8} />\n\n                {selected && (\n                  <Icon name=\"checkmark-filled\" color={colors.positive[500]} size={16} />\n                )}\n              </Box>\n            );\n          }}\n          readOnly={readOnly}\n          disabled={disabled}\n          error={error}\n          hideErrors={hideErrors}\n          emptyResultText={noSuggestionLabel}\n          onChange={onChange}\n          onValueChange={noop}\n          onSelectItem={item => onChangeText(stringifyTime(item))}\n        />\n      )}\n    </Rifm>\n  );\n};\n\nexport type TimeRangePickerProps = {\n  value: { start?: string; end?: string };\n  onChange: (value: { start?: string; end?: string }) => void;\n  intervalInMinutes?: number;\n  nbMaxSuggestions?: number;\n  readOnly?: boolean;\n  disabled?: boolean;\n  error?: string;\n  startLabel: string;\n  endLabel: string;\n  minutesLabel: string;\n  hoursLabel: string;\n  noSuggestionLabel: string;\n};\n\nexport const TimeRangePicker = ({\n  value,\n  onChange,\n  intervalInMinutes = DEFAULT_INTERVAL_IN_MINUTES,\n  nbMaxSuggestions,\n  readOnly,\n  disabled,\n  error,\n  startLabel,\n  endLabel,\n  minutesLabel,\n  hoursLabel,\n  noSuggestionLabel,\n}: TimeRangePickerProps) => {\n  const start = parseTime(value.start ?? \"\");\n\n  const handleStartChange = (startValue: string) => {\n    onChange({\n      start: startValue,\n      end: value.end,\n    });\n  };\n\n  const handleEndChange = (endValue: string) => {\n    onChange({\n      start: value.start,\n      end: endValue,\n    });\n  };\n\n  return (\n    <View>\n      <Box direction=\"row\" alignItems=\"end\">\n        <LakeLabel\n          label={startLabel}\n          style={styles.label}\n          render={() => (\n            <TimePicker\n              value={value.start}\n              intervalInMinutes={intervalInMinutes}\n              nbMaxSuggestions={nbMaxSuggestions}\n              error={error}\n              hideErrors={true}\n              disabled={disabled}\n              readOnly={readOnly}\n              noSuggestionLabel={noSuggestionLabel}\n              onChangeText={handleStartChange}\n            />\n          )}\n        />\n\n        <Space width={12} />\n\n        <Box style={styles.arrowContainer} justifyContent=\"center\">\n          <Icon name=\"arrow-right-filled\" size={20} />\n        </Box>\n\n        <Space width={12} />\n\n        <LakeLabel\n          label={endLabel}\n          style={styles.label}\n          render={() => (\n            <TimePicker\n              value={value.end}\n              intervalInMinutes={intervalInMinutes}\n              nbMaxSuggestions={nbMaxSuggestions}\n              suggestionStart={start\n                .map(time => floorTime(time, intervalInMinutes))\n                .map(time => addMinutes(time, intervalInMinutes))\n                .match({\n                  Some: time => time,\n                  None: () => undefined,\n                })}\n              suggestionSuffix={time => {\n                if (start.isNone()) {\n                  return \"\";\n                }\n                const durationInMinutes = timeToMinutes(time) - timeToMinutes(start.value);\n                if (durationInMinutes > 0 && durationInMinutes <= 60) {\n                  const timeDuration = minutesToTime(durationInMinutes);\n                  return `(${formatTimeDuration(timeDuration, minutesLabel, hoursLabel)})`;\n                }\n                return \"\";\n              }}\n              error={error}\n              hideErrors={true}\n              disabled={disabled}\n              readOnly={readOnly}\n              noSuggestionLabel={noSuggestionLabel}\n              onChangeText={handleEndChange}\n            />\n          )}\n        />\n      </Box>\n\n      <Space height={4} />\n\n      <LakeText variant=\"smallRegular\" color={colors.negative[500]}>\n        {error ?? \" \"}\n      </LakeText>\n    </View>\n  );\n};\n"],"names":["styles","StyleSheet","DEFAULT_START_TIME","DEFAULT_END_TIME","DEFAULT_INTERVAL_IN_MINUTES","rifmTimeProps","getRifmProps","parseTime","time","hours","minutes","isNullish","Option","parseTimeRange","value","start","isNotNullishOrEmpty","end","parseTypingHours","parsedHours","stringifyTime","timeToMinutes","minutesToTime","addMinutes","floorTime","intervalInMinutes","flooredMinutes","isTimeBefore","time1","time2","validateTimeRange","range","minTime","times","timesInMinutes","minTimeInMinutes","maxTime","maxTimeInMinutes","generateTimeList","startMinutes","endMinutes","timeList","i","formatTimeDuration","minutesLabel","hoursLabel","TimePicker","onChangeText","suggestionStart","suggestionEnd","nbMaxSuggestions","suggestionSuffix","readOnly","disabled","error","hideErrors","noSuggestionLabel","typingHour","optionsInterval","useMemo","hour","options","items","AsyncData","Result","jsx","Rifm","onChange","LakeCombobox","item","text","selected","suffix","label","jsxs","Box","LakeText","colors","Fill","Icon","noop","TimeRangePicker","startLabel","endLabel","handleStartChange","startValue","handleEndChange","endValue","View","LakeLabel","Space","durationInMinutes","timeDuration"],"mappings":"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"}