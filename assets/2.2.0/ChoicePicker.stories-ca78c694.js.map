{"version":3,"file":"ChoicePicker.stories-ca78c694.js","sources":["../../../packages/lake/src/utils/viewport.ts","../../../packages/lake/src/components/ChoicePicker.tsx"],"sourcesContent":["import { Future } from \"@swan-io/boxed\";\nimport { isNotNullish } from \"./nullish\";\nimport { isSafari } from \"./userAgent\";\n\n// Prevents Safari from zooming automatically on inputs, still allow user to zoom manually\nexport const preventSafariAutoZoomOnInputs = () => {\n  if (isSafari) {\n    const viewport = document.querySelector(\"meta[name=viewport]\");\n    const content = viewport?.getAttribute(\"content\");\n\n    if (isNotNullish(viewport) && isNotNullish(content)) {\n      viewport.setAttribute(\"content\", content + \", maximum-scale=1.0\");\n    }\n  }\n};\n\n// When using `node.scroll()` with smooth behavior, there isn't any event to detect when the scroll animation is finished\n// We need this also with `ScrollView.scrollTo` (which just call the native node.scroll function)\n// More info about why this workaround: https://stackoverflow.com/a/60001032\nexport const detectScrollAnimationEnd = (element: HTMLElement): Future<void> => {\n  let lastScrollTop = element.scrollTop;\n  let lastScrollLeft = element.scrollLeft;\n\n  return Future.make<void>(resolve => {\n    let frame: number | undefined;\n\n    // We need to wait a bit before starting the loop because first requestAnimationFrame is called before the scroll animation starts\n    const timeout = setTimeout(() => {\n      const loop = () => {\n        frame = requestAnimationFrame(() => {\n          if (lastScrollTop !== element.scrollTop || lastScrollLeft !== element.scrollLeft) {\n            lastScrollTop = element.scrollTop;\n            lastScrollLeft = element.scrollLeft;\n            loop();\n          } else {\n            resolve();\n          }\n        });\n      };\n\n      loop();\n    }, 50);\n\n    return () => {\n      clearTimeout(timeout);\n      if (frame != null) {\n        cancelAnimationFrame(frame);\n      }\n    };\n  });\n};\n","import { ReactNode, useEffect, useRef, useState } from \"react\";\nimport { ScrollView, StyleSheet, View } from \"react-native\";\nimport { match } from \"ts-pattern\";\nimport { breakpoints, negativeSpacings, spacings } from \"../constants/design\";\nimport { useResponsive } from \"../hooks/useResponsive\";\nimport { clampValue } from \"../utils/math\";\nimport { detectScrollAnimationEnd } from \"../utils/viewport\";\nimport { LakeButton } from \"./LakeButton\";\nimport { LakeRadio } from \"./LakeRadio\";\nimport { Pressable } from \"./Pressable\";\nimport { Space } from \"./Space\";\nimport { Tile } from \"./Tile\";\n\nconst styles = StyleSheet.create({\n  root: {\n    alignSelf: \"stretch\",\n    alignItems: \"stretch\",\n    flexGrow: 1,\n    overflow: \"hidden\",\n    marginHorizontal: negativeSpacings[12],\n  },\n  scrollSnap: {\n    scrollSnapType: \"x mandatory\",\n  },\n  container: {\n    alignSelf: \"stretch\",\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    alignItems: \"stretch\",\n    justifyContent: \"center\",\n  },\n  mobileContainer: {\n    flexWrap: \"nowrap\",\n    justifyContent: \"flex-start\",\n    transitionProperty: \"transform\",\n    transitionDuration: \"300ms\",\n    transitionTimingFunction: \"ease-in-out\",\n  },\n  item: {\n    flexGrow: 0,\n    flexBasis: \"33.333%\",\n    maxWidth: 300,\n    padding: spacings[12],\n  },\n  itemAnimation: {\n    transform: \"translateZ(0px)\",\n    animationKeyframes: {\n      from: {\n        opacity: 0,\n        transform: \"translateZ(0px) translateX(50px)\",\n      },\n      to: {\n        opacity: 1,\n        transform: \"translateZ(0px) translateX(0px)\",\n      },\n    },\n    animationDuration: \"200ms\",\n    animationFillMode: \"backwards\",\n    animationTimingFunction: \"ease-in-out\",\n  },\n  itemLarge: {\n    flexBasis: \"50%\",\n    maxWidth: \"none\",\n  },\n  itemSmallViewport: {\n    width: \"100%\",\n    flexBasis: \"auto\",\n    maxWidth: \"none\",\n    scrollSnapAlign: \"center\",\n  },\n  tileContents: {\n    alignItems: \"center\",\n    alignSelf: \"stretch\",\n    flexGrow: 1,\n  },\n  tileRenderedContents: {\n    alignItems: \"center\",\n    alignSelf: \"stretch\",\n    flexGrow: 1,\n  },\n  leftButton: {\n    position: \"absolute\",\n    top: \"50%\",\n    left: negativeSpacings[24],\n    transform: \"translateY(-50%)\",\n    borderTopLeftRadius: 0,\n    borderBottomLeftRadius: 0,\n    borderWidth: 1,\n    borderLeftWidth: 0,\n  },\n  rightButton: {\n    position: \"absolute\",\n    top: \"50%\",\n    right: negativeSpacings[24],\n    transform: \"translateY(-50%)\",\n    borderTopRightRadius: 0,\n    borderBottomRightRadius: 0,\n    borderWidth: 1,\n    borderRightWidth: 0,\n  },\n});\n\ntype Props<T> = {\n  items: T[];\n  large?: boolean;\n  renderItem: (value: T) => ReactNode;\n  value?: T;\n  getId?: (item: T) => unknown;\n  onChange: (value: T) => void;\n};\n\nconst identity = <T,>(x: T) => x;\n\nexport const ChoicePicker = <T,>({\n  items,\n  getId = identity,\n  large = false,\n  renderItem,\n  value,\n  onChange,\n}: Props<T>) => {\n  const containerRef = useRef<ScrollView | null>(null);\n  const { desktop } = useResponsive(breakpoints.medium);\n  const [mobilePosition, setMobilePosition] = useState<\"start\" | \"middle\" | \"end\">(\"start\");\n\n  useEffect(() => {\n    if (desktop) {\n      return;\n    }\n\n    // auto scroll to selected value on mobile\n    const scrollContainer = containerRef.current;\n    const index = items.findIndex(item => value === item);\n    if (index !== -1 && scrollContainer instanceof HTMLDivElement) {\n      const width = scrollContainer.offsetWidth;\n      scrollContainer.scrollTo({ x: index * width, animated: false });\n    }\n\n    // if no value is selected, select first item\n    if (value == null && items[0] != null) {\n      onChange(items[0]);\n    }\n    // disable exhaustive-deps because we only want to run this effect only when screen size go from desktop to mobile\n  }, [desktop]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const onScroll = () => {\n    // prevent scroll event when we change screen size from mobile to desktop\n    if (desktop) {\n      return;\n    }\n\n    const scrollContainer = containerRef.current;\n    if (scrollContainer instanceof HTMLDivElement) {\n      const scrollLeft = scrollContainer.scrollLeft;\n      const width = scrollContainer.offsetWidth;\n      const index = clampValue(0, items.length - 1)(Math.round(scrollLeft / width));\n      const item = items[index];\n      if (item != null) {\n        onChange(item);\n      }\n\n      match(index)\n        .with(0, () => setMobilePosition(\"start\"))\n        .with(items.length - 1, () => setMobilePosition(\"end\"))\n        .otherwise(() => setMobilePosition(\"middle\"));\n    }\n  };\n\n  const onPressPrevious = () => {\n    const scrollContainer = containerRef.current;\n    if (scrollContainer instanceof HTMLDivElement) {\n      const scrollLeft = scrollContainer.scrollLeft;\n      const width = scrollContainer.offsetWidth;\n      const index = Math.round(scrollLeft / width);\n      const previousIndex = Math.max(0, index - 1);\n\n      // remove scroll snap during scroll animation to avoid weird behavior on older browsers\n      scrollContainer.style.scrollSnapType = \"none\";\n      containerRef.current?.scrollTo({ x: previousIndex * width, animated: true });\n      detectScrollAnimationEnd(scrollContainer).onResolve(() => {\n        // set back scroll snap\n        // @ts-expect-error\n        scrollContainer.style.scrollSnapType = null;\n      });\n    }\n  };\n\n  const onPressNext = () => {\n    const scrollContainer = containerRef.current;\n    if (scrollContainer instanceof HTMLDivElement) {\n      const scrollLeft = scrollContainer.scrollLeft;\n      const width = scrollContainer.offsetWidth;\n      const index = Math.round(scrollLeft / width);\n      const nextIndex = Math.min(items.length - 1, index + 1);\n\n      // remove scroll snap during scroll animation to avoid weird behavior on older browsers\n      scrollContainer.style.scrollSnapType = \"none\";\n      containerRef.current?.scrollTo({ x: nextIndex * width, animated: true });\n      detectScrollAnimationEnd(scrollContainer).onResolve(() => {\n        // set back scroll snap\n        // @ts-expect-error\n        scrollContainer.style.scrollSnapType = null;\n      });\n    }\n  };\n\n  return (\n    <View>\n      <View style={styles.root}>\n        <ScrollView\n          ref={containerRef}\n          horizontal={!desktop}\n          onScroll={onScroll}\n          scrollEventThrottle={200}\n          style={styles.scrollSnap}\n          contentContainerStyle={[\n            styles.container,\n            !desktop && styles.mobileContainer,\n            !desktop && { width: `${items.length * 100}%` },\n          ]}\n        >\n          {items.map((item, index) => (\n            <Pressable\n              key={String(index)}\n              style={[\n                styles.item,\n                desktop && styles.itemAnimation, // set enter animation only on desktop because it can break scroll snap\n                desktop && { animationDelay: `${200 + 100 * index}ms` },\n                large && styles.itemLarge,\n                !desktop && styles.itemSmallViewport,\n                !desktop && { width: `${100 / items.length}%` },\n              ]}\n              onPress={() => onChange(item)}\n            >\n              {({ hovered }) => (\n                <Tile\n                  hovered={hovered}\n                  selected={value != null && getId(item) === getId(value)}\n                  flexGrow={1}\n                >\n                  <View style={styles.tileContents}>\n                    <View style={styles.tileRenderedContents}>{renderItem(item)}</View>\n\n                    {desktop && (\n                      <>\n                        <Space height={24} />\n                        <LakeRadio value={value != null && getId(item) === getId(value)} />\n                      </>\n                    )}\n                  </View>\n                </Tile>\n              )}\n            </Pressable>\n          ))}\n        </ScrollView>\n      </View>\n\n      {!desktop && (\n        <LakeButton\n          icon=\"chevron-left-filled\"\n          mode=\"secondary\"\n          forceBackground={true}\n          onPress={onPressPrevious}\n          disabled={mobilePosition === \"start\"}\n          style={styles.leftButton}\n        />\n      )}\n\n      {!desktop && (\n        <LakeButton\n          icon=\"chevron-right-filled\"\n          mode=\"secondary\"\n          forceBackground={true}\n          onPress={onPressNext}\n          disabled={mobilePosition === \"end\"}\n          style={styles.rightButton}\n        />\n      )}\n    </View>\n  );\n};\n"],"names":["detectScrollAnimationEnd","element","lastScrollTop","lastScrollLeft","Future","resolve","frame","timeout","loop","styles","StyleSheet","negativeSpacings","spacings","identity","x","ChoicePicker","items","getId","large","renderItem","value","onChange","containerRef","useRef","desktop","useResponsive","breakpoints","mobilePosition","setMobilePosition","useState","useEffect","scrollContainer","index","item","width","onScroll","scrollLeft","clampValue","match","onPressPrevious","previousIndex","_a","onPressNext","nextIndex","jsxs","View","jsx","ScrollView","Pressable","hovered","Tile","Fragment","Space","LakeRadio","LakeButton"],"mappings":"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"}