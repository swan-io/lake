{"version":3,"file":"ChoicePicker.stories-CCB21gya.js","sources":["../../../packages/lake/src/utils/math.ts","../../../packages/lake/src/utils/viewport.ts","../../../packages/shared-business/src/components/ChoicePicker.tsx"],"sourcesContent":["import { isNotNullish, isNullish } from \"./nullish\";\n\ntype InterpolateTuple = [number, number, ...number[]];\ntype FixedLength<L extends number> = number[] & { 0: number; length: L };\n\ntype InterpolateParams<T extends InterpolateTuple> = {\n  inputRange: T;\n  outputRange: FixedLength<T[\"length\"]>;\n  clamp?: boolean;\n};\n\nconst getValue = (array: number[], index: number, name: string): number => {\n  const value = array[index];\n  if (isNullish(value)) {\n    throw new Error(`Interpolation Error: index \"${index}\" doesn't exists in ${name}`);\n  }\n  return value;\n};\n\nexport const clampValue =\n  (min: number, max: number) =>\n  (value: number): number =>\n    Math.max(Math.min(value, max), min);\n\n// Here we can disable no-non-null-assertion because this function is called in interpolate which have types checking if there is at least 2 values in range\nconst getRangeIndexes = <T extends InterpolateTuple>(range: T, value: number): [number, number] => {\n  if (value < range[0]) {\n    return [0, 1];\n  }\n\n  const maxIndex = range.length - 1;\n  for (let i = 0; i <= maxIndex; i += 1) {\n    const nextIndex = i + 1;\n    const startRange = getValue(range, i, \"range\");\n    const endRange = range[nextIndex];\n\n    if (isNotNullish(endRange) && value > startRange && value < endRange) {\n      return [i, nextIndex];\n    }\n  }\n\n  // if no values was found, it means value is upper than last range value\n  return [maxIndex - 1, maxIndex];\n};\n\n/**\n * This function is similar to `Animated.interpolate` except this one can be used with numbers\n * Whereas `Animated.interpolate` works only with animated values and return a listener, not a single value\n */\nexport const interpolate = <T extends InterpolateTuple>({\n  inputRange: input,\n  outputRange: output,\n  clamp = true,\n}: InterpolateParams<T>): ((value: number) => number) => {\n  return (value: number): number => {\n    const [startIndex, endIndex] = getRangeIndexes(input, value);\n    const inputStart = getValue(input, startIndex, \"inputRange\");\n    const inputEnd = getValue(input, endIndex, \"inputRange\");\n    const lastInput = getValue(input, input.length - 1, \"inputRange\");\n    const outputStart = getValue(output, startIndex, \"outputRange\");\n    const outputEnd = getValue(output, endIndex, \"outputRange\");\n\n    const inputRange = inputEnd - inputStart;\n    const outputRange = outputEnd - outputStart;\n\n    const valueToConvert = clamp ? clampValue(input[0], lastInput)(value) : value;\n\n    const valueWithoutOffset = valueToConvert - inputStart;\n    const outputWithoutOffset = (outputRange * valueWithoutOffset) / inputRange;\n    const outputValue = outputWithoutOffset + outputStart;\n\n    return outputValue;\n  };\n};\n\ntype ElasticParams = {\n  elasticLength?: number; // the maximum value you can reach\n  elasticStrength?: number; // higher value, maximum value reached faster\n};\n\n/**\n * This function takes as input a number from 0 to Infinity and returns a number from 0 to elasticLength\n * With an exponential curve giving a feeling of elasticity\n * This kind of function can be used to:\n *  - recreate effect like scroll bounce on iOS\n *  - limit grab smoothly with touch interaction\n */\nexport const limitElastic =\n  ({ elasticLength = 100, elasticStrength = 0.008 }: ElasticParams) =>\n  (value: number): number =>\n    elasticLength * (1 - Math.exp(-elasticStrength * value));\n","import { Future } from \"@swan-io/boxed\";\nimport { isNotNullish } from \"./nullish\";\nimport { isSafari } from \"./userAgent\";\n\n/**\n * Prevents Safari from zooming automatically on inputs, still allow user to zoom manually\n * @deprecated\n */\nexport const preventSafariAutoZoomOnInputs = () => {\n  if (isSafari) {\n    const viewport = document.querySelector(\"meta[name=viewport]\");\n    const content = viewport?.getAttribute(\"content\");\n\n    if (isNotNullish(viewport) && isNotNullish(content)) {\n      viewport.setAttribute(\"content\", content + \", maximum-scale=1.0\");\n    }\n  }\n};\n\n// When using `node.scroll()` with smooth behavior, there isn't any event to detect when the scroll animation is finished\n// We need this also with `ScrollView.scrollTo` (which just call the native node.scroll function)\n// More info about why this workaround: https://stackoverflow.com/a/60001032\nexport const detectScrollAnimationEnd = (element: HTMLElement): Future<void> => {\n  let lastScrollTop = element.scrollTop;\n  let lastScrollLeft = element.scrollLeft;\n\n  return Future.make<void>(resolve => {\n    let frame: number | undefined;\n\n    // We need to wait a bit before starting the loop because first requestAnimationFrame is called before the scroll animation starts\n    const timeout = setTimeout(() => {\n      const loop = () => {\n        frame = requestAnimationFrame(() => {\n          if (lastScrollTop !== element.scrollTop || lastScrollLeft !== element.scrollLeft) {\n            lastScrollTop = element.scrollTop;\n            lastScrollLeft = element.scrollLeft;\n            loop();\n          } else {\n            resolve();\n          }\n        });\n      };\n\n      loop();\n    }, 50);\n\n    return () => {\n      clearTimeout(timeout);\n      if (frame != null) {\n        cancelAnimationFrame(frame);\n      }\n    };\n  });\n};\n","import { LakeButton } from \"@swan-io/lake/src/components/LakeButton\";\nimport { LakeRadio } from \"@swan-io/lake/src/components/LakeRadio\";\nimport { Pressable } from \"@swan-io/lake/src/components/Pressable\";\nimport { ScrollView, ScrollViewRef } from \"@swan-io/lake/src/components/ScrollView\";\nimport { Space } from \"@swan-io/lake/src/components/Space\";\nimport { Tile } from \"@swan-io/lake/src/components/Tile\";\nimport { commonStyles } from \"@swan-io/lake/src/constants/commonStyles\";\nimport { breakpoints, negativeSpacings, spacings } from \"@swan-io/lake/src/constants/design\";\nimport { useResponsive } from \"@swan-io/lake/src/hooks/useResponsive\";\nimport { clampValue } from \"@swan-io/lake/src/utils/math\";\nimport { detectScrollAnimationEnd } from \"@swan-io/lake/src/utils/viewport\";\nimport { ReactNode, useEffect, useRef, useState } from \"react\";\nimport { StyleSheet, View } from \"react-native\";\nimport { match } from \"ts-pattern\";\nimport { t } from \"../utils/i18n\";\n\nconst styles = StyleSheet.create({\n  root: {\n    alignSelf: \"stretch\",\n    alignItems: \"stretch\",\n    flexGrow: 1,\n    overflow: \"hidden\",\n    marginHorizontal: negativeSpacings[12],\n  },\n  scrollSnap: {\n    scrollSnapType: \"x mandatory\",\n  },\n  container: {\n    alignSelf: \"stretch\",\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    alignItems: \"stretch\",\n    justifyContent: \"center\",\n  },\n  mobileContainer: {\n    flexWrap: \"nowrap\",\n    justifyContent: \"flex-start\",\n    transitionProperty: \"transform\",\n    transitionDuration: \"300ms\",\n    transitionTimingFunction: \"ease-in-out\",\n  },\n  item: {\n    flexGrow: 0,\n    flexBasis: \"33.333%\",\n    maxWidth: 300,\n    padding: spacings[12],\n  },\n  itemAnimation: {\n    transform: \"translateZ(0px)\",\n    animationKeyframes: {\n      from: {\n        opacity: 0,\n        transform: \"translateZ(0px) translateX(50px)\",\n      },\n      to: {\n        opacity: 1,\n        transform: \"translateZ(0px) translateX(0px)\",\n      },\n    },\n    animationDuration: \"200ms\",\n    animationFillMode: \"backwards\",\n    animationTimingFunction: \"ease-in-out\",\n  },\n  itemLarge: {\n    flexBasis: \"50%\",\n    maxWidth: \"none\",\n  },\n  itemSmallViewport: {\n    width: \"100%\",\n    flexBasis: \"auto\",\n    maxWidth: \"none\",\n    scrollSnapAlign: \"center\",\n  },\n  tileContents: {\n    alignItems: \"center\",\n    alignSelf: \"stretch\",\n    flexGrow: 1,\n  },\n  tileRenderedContents: {\n    alignItems: \"center\",\n    alignSelf: \"stretch\",\n    flexGrow: 1,\n  },\n  leftButton: {\n    position: \"absolute\",\n    top: \"50%\",\n    left: negativeSpacings[24],\n    transform: \"translateY(-50%)\",\n    borderTopLeftRadius: 0,\n    borderBottomLeftRadius: 0,\n    borderWidth: 1,\n    borderLeftWidth: 0,\n  },\n  rightButton: {\n    position: \"absolute\",\n    top: \"50%\",\n    right: negativeSpacings[24],\n    transform: \"translateY(-50%)\",\n    borderTopRightRadius: 0,\n    borderBottomRightRadius: 0,\n    borderWidth: 1,\n    borderRightWidth: 0,\n  },\n});\n\ntype Props<T> = {\n  items: T[];\n  large?: boolean;\n  renderItem: (value: T) => ReactNode;\n  value?: T;\n  getId?: (item: T) => unknown;\n  onChange: (value: T) => void;\n  disabled?: boolean;\n  tile?: boolean;\n};\n\nconst identity = <T,>(x: T) => x;\n\nexport const ChoicePicker = <T,>({\n  tile = true,\n  items,\n  getId = identity,\n  large = false,\n  renderItem,\n  value,\n  disabled = false,\n  onChange,\n}: Props<T>) => {\n  const containerRef = useRef<ScrollViewRef | null>(null);\n  const { desktop } = useResponsive(breakpoints.medium);\n  const [mobilePosition, setMobilePosition] = useState<\"start\" | \"middle\" | \"end\">(\"start\");\n\n  useEffect(() => {\n    if (desktop) {\n      return;\n    }\n\n    // auto scroll to selected value on mobile\n    const scrollContainer = containerRef.current;\n    const index = items.findIndex(item => value === item);\n\n    if (index !== -1 && scrollContainer instanceof HTMLDivElement) {\n      const width = scrollContainer.offsetWidth;\n      scrollContainer.scrollTo({ x: index * width, animated: false });\n    }\n\n    // if no value is selected, select first item\n    if (value == null && items[0] != null) {\n      onChange(items[0]);\n    }\n    // disable exhaustive-deps because we only want to run this effect only when screen size go from desktop to mobile\n  }, [desktop]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const onScroll = () => {\n    // prevent scroll event when we change screen size from mobile to desktop\n    if (desktop) {\n      return;\n    }\n\n    const scrollContainer = containerRef.current;\n    if (scrollContainer instanceof HTMLDivElement) {\n      const scrollLeft = scrollContainer.scrollLeft;\n      const width = scrollContainer.offsetWidth;\n      const index = clampValue(0, items.length - 1)(Math.round(scrollLeft / width));\n      const item = items[index];\n      if (item != null) {\n        onChange(item);\n      }\n\n      match(index)\n        .with(0, () => setMobilePosition(\"start\"))\n        .with(items.length - 1, () => setMobilePosition(\"end\"))\n        .otherwise(() => setMobilePosition(\"middle\"));\n    }\n  };\n\n  const onPressPrevious = () => {\n    const scrollContainer = containerRef.current;\n    if (scrollContainer instanceof HTMLDivElement) {\n      const scrollLeft = scrollContainer.scrollLeft;\n      const width = scrollContainer.offsetWidth;\n      const index = Math.round(scrollLeft / width);\n      const previousIndex = Math.max(0, index - 1);\n\n      // remove scroll snap during scroll animation to avoid weird behavior on older browsers\n      scrollContainer.style.scrollSnapType = \"none\";\n      containerRef.current?.scrollTo({ x: previousIndex * width, animated: true });\n      detectScrollAnimationEnd(scrollContainer).onResolve(() => {\n        // set back scroll snap\n        // @ts-expect-error\n        scrollContainer.style.scrollSnapType = null;\n      });\n    }\n  };\n\n  const onPressNext = () => {\n    const scrollContainer = containerRef.current;\n    if (scrollContainer instanceof HTMLDivElement) {\n      const scrollLeft = scrollContainer.scrollLeft;\n      const width = scrollContainer.offsetWidth;\n      const index = Math.round(scrollLeft / width);\n      const nextIndex = Math.min(items.length - 1, index + 1);\n\n      // remove scroll snap during scroll animation to avoid weird behavior on older browsers\n      scrollContainer.style.scrollSnapType = \"none\";\n      containerRef.current?.scrollTo({ x: nextIndex * width, animated: true });\n      detectScrollAnimationEnd(scrollContainer).onResolve(() => {\n        // set back scroll snap\n        // @ts-expect-error\n        scrollContainer.style.scrollSnapType = null;\n      });\n    }\n  };\n\n  return (\n    <View>\n      <View style={styles.root}>\n        <ScrollView\n          ref={containerRef}\n          horizontal={!desktop}\n          onScroll={onScroll}\n          scrollEventThrottle={200}\n          style={styles.scrollSnap}\n          contentContainerStyle={[\n            styles.container,\n            !desktop && styles.mobileContainer,\n            !desktop && { width: `${items.length * 100}%` },\n          ]}\n        >\n          {items.map((item, index) => (\n            <Pressable\n              key={String(index)}\n              disabled={disabled}\n              style={[\n                styles.item,\n                disabled && commonStyles.disabled,\n                desktop && styles.itemAnimation, // set enter animation only on desktop because it can break scroll snap\n                desktop && { animationDelay: `${200 + 100 * index}ms` },\n                large && styles.itemLarge,\n                !desktop && styles.itemSmallViewport,\n                !desktop && { width: `${100 / items.length}%` },\n              ]}\n              onPress={() => onChange(item)}\n            >\n              {({ hovered }) => {\n                const tileContent = (\n                  <View style={styles.tileContents}>\n                    <View style={styles.tileRenderedContents}>{renderItem(item)}</View>\n\n                    {desktop && (\n                      <>\n                        <Space height={24} />\n                        <LakeRadio value={value != null && getId(item) === getId(value)} />\n                      </>\n                    )}\n                  </View>\n                );\n                return tile ? (\n                  <Tile\n                    hovered={hovered}\n                    selected={value != null && getId(item) === getId(value)}\n                    flexGrow={1}\n                  >\n                    {tileContent}\n                  </Tile>\n                ) : (\n                  tileContent\n                );\n              }}\n            </Pressable>\n          ))}\n        </ScrollView>\n      </View>\n\n      {!desktop && (\n        <LakeButton\n          icon=\"chevron-left-filled\"\n          mode=\"secondary\"\n          forceBackground={true}\n          onPress={onPressPrevious}\n          disabled={mobilePosition === \"start\" || disabled}\n          style={styles.leftButton}\n          ariaLabel={t(\"common.previous\")}\n        />\n      )}\n\n      {!desktop && (\n        <LakeButton\n          icon=\"chevron-right-filled\"\n          mode=\"secondary\"\n          forceBackground={true}\n          onPress={onPressNext}\n          disabled={mobilePosition === \"end\" || disabled}\n          style={styles.rightButton}\n          ariaLabel={t(\"common.next\")}\n        />\n      )}\n    </View>\n  );\n};\n"],"names":["clampValue","min","max","value","detectScrollAnimationEnd","element","lastScrollTop","lastScrollLeft","Future","resolve","frame","timeout","loop","styles","StyleSheet","negativeSpacings","spacings","identity","x","ChoicePicker","tile","items","getId","large","renderItem","disabled","onChange","containerRef","useRef","desktop","useResponsive","breakpoints","mobilePosition","setMobilePosition","useState","useEffect","scrollContainer","index","item","width","onScroll","scrollLeft","match","onPressPrevious","previousIndex","_a","onPressNext","nextIndex","View","jsx","ScrollView","Pressable","commonStyles","hovered","tileContent","jsxs","Fragment","Space","LakeRadio","Tile","LakeButton","t"],"mappings":"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"}