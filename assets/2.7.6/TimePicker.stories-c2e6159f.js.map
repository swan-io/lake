{"version":3,"file":"TimePicker.stories-c2e6159f.js","sources":["../../../packages/lake/src/components/TimePicker.tsx"],"sourcesContent":["import { AsyncData, Option, Result } from \"@swan-io/boxed\";\nimport { useMemo } from \"react\";\nimport { StyleSheet, View } from \"react-native\";\nimport { Rifm } from \"rifm\";\nimport { colors } from \"../constants/design\";\nimport { noop } from \"../utils/function\";\nimport { isNotNullishOrEmpty, isNullish } from \"../utils/nullish\";\nimport { getRifmProps } from \"../utils/rifm\";\nimport { Box } from \"./Box\";\nimport { Fill } from \"./Fill\";\nimport { Icon } from \"./Icon\";\nimport { LakeCombobox } from \"./LakeCombobox\";\nimport { LakeLabel } from \"./LakeLabel\";\nimport { LakeText } from \"./LakeText\";\nimport { Space } from \"./Space\";\n\nconst styles = StyleSheet.create({\n  label: {\n    flex: 1,\n  },\n  arrowContainer: {\n    height: 40, // input height\n  },\n});\n\ntype Time = {\n  hour: number;\n  minute: number;\n};\n\nconst DEFAULT_START_TIME: Time = { hour: 0, minute: 0 };\nconst DEFAULT_END_TIME: Time = { hour: 23, minute: 59 };\nconst DEFAULT_INTERVAL_IN_MINUTES = 15;\n\nconst rifmTimeProps = getRifmProps({\n  accept: \"numeric\",\n  charMap: { 2: \":\" },\n  maxLength: 4,\n});\n\nexport const parseTime = (time: string): Option<Time> => {\n  const [hours, minutes] = time.split(\":\").map(Number);\n\n  if (isNullish(hours) || isNaN(hours) || isNullish(minutes) || isNaN(minutes)) {\n    return Option.None();\n  }\n\n  return Option.Some({ hour: hours, minute: minutes });\n};\n\nexport const parseTimeRange = (value: {\n  start?: string;\n  end?: string;\n}): { start: Option<Time>; end: Option<Time> } => {\n  const start = isNotNullishOrEmpty(value.start) ? parseTime(value.start) : Option.None();\n  const end = isNotNullishOrEmpty(value.end) ? parseTime(value.end) : Option.None();\n\n  return { start, end };\n};\n\nconst parseTypingHours = (time: string): Option<number> => {\n  const [hours, minutes] = time.split(\":\");\n\n  if (isNullish(hours) || hours?.length !== 2 || isNotNullishOrEmpty(minutes)) {\n    return Option.None();\n  }\n\n  const parsedHours = Number(hours);\n\n  if (parsedHours < 0 || parsedHours > 23) {\n    return Option.None();\n  }\n\n  if (isNaN(parsedHours)) {\n    return Option.None();\n  }\n\n  return Option.Some(parsedHours);\n};\n\nconst stringifyTime = (time: Time): string => {\n  return `${time.hour.toString().padStart(2, \"0\")}:${time.minute.toString().padStart(2, \"0\")}`;\n};\n\nconst timeToMinutes = (time: Time): number => {\n  return time.hour * 60 + time.minute;\n};\n\nconst minutesToTime = (minutes: number): Time => {\n  return {\n    hour: Math.floor(minutes / 60),\n    minute: minutes % 60,\n  };\n};\n\nconst addMinutes = (time: Time, minutes: number): Time => {\n  return minutesToTime(timeToMinutes(time) + minutes);\n};\n\nconst floorTime = (time: Time, intervalInMinutes: number): Time => {\n  const minutes = timeToMinutes(time);\n  const flooredMinutes = Math.floor(minutes / intervalInMinutes) * intervalInMinutes;\n\n  return minutesToTime(flooredMinutes);\n};\n\nexport const validateTime = (time: Time): boolean => {\n  return time.hour >= 0 && time.hour <= 23 && time.minute >= 0 && time.minute <= 59;\n};\n\nconst isTimeBefore = (time1: Time, time2: Time): boolean => {\n  return timeToMinutes(time1) < timeToMinutes(time2);\n};\n\nexport const validateTimeRange = (range: { start: Option<Time>; end: Option<Time> }): boolean => {\n  if (range.start.isNone() || range.end.isNone()) {\n    return true;\n  }\n\n  return isTimeBefore(range.start.value, range.end.value);\n};\n\nconst minTime = (...times: Time[]): Time => {\n  const timesInMinutes = times.map(timeToMinutes);\n  const minTimeInMinutes = Math.min(...timesInMinutes);\n  return minutesToTime(minTimeInMinutes);\n};\n\nconst maxTime = (...times: Time[]): Time => {\n  const timesInMinutes = times.map(timeToMinutes);\n  const maxTimeInMinutes = Math.max(...timesInMinutes);\n  return minutesToTime(maxTimeInMinutes);\n};\n\nconst generateTimeList = (start: Time, end: Time, intervalInMinutes: number): Time[] => {\n  const startMinutes = timeToMinutes(start);\n  const endMinutes = timeToMinutes(end);\n\n  const timeList = [];\n  for (let i = startMinutes; i <= endMinutes; i += intervalInMinutes) {\n    const time = minutesToTime(i);\n    timeList.push(time);\n  }\n\n  return timeList;\n};\n\nconst formatTimeDuration = (time: Time, minutesLabel: string, hoursLabel: string): string => {\n  if (time.hour === 0) {\n    return `${time.minute} ${minutesLabel}`;\n  }\n\n  if (time.minute === 0) {\n    return `${time.hour} ${hoursLabel}`;\n  }\n\n  return `${time.hour} ${hoursLabel} ${time.minute} ${minutesLabel}`;\n};\n\nexport type TimePickerProps = {\n  value?: string;\n  onChangeText: (value: string) => void;\n  suggestionStart?: Time;\n  suggestionEnd?: Time;\n  intervalInMinutes?: number;\n  nbMaxSuggestions?: number;\n  suggestionSuffix?: (option: Time) => string;\n  readOnly?: boolean;\n  disabled?: boolean;\n  error?: string;\n  hideErrors?: boolean;\n  noSuggestionLabel: string;\n};\n\nexport const TimePicker = ({\n  value,\n  onChangeText,\n  suggestionStart = DEFAULT_START_TIME,\n  suggestionEnd = DEFAULT_END_TIME,\n  intervalInMinutes = DEFAULT_INTERVAL_IN_MINUTES,\n  nbMaxSuggestions,\n  suggestionSuffix,\n  readOnly,\n  disabled,\n  error,\n  hideErrors,\n  noSuggestionLabel,\n}: TimePickerProps) => {\n  const typingHour = parseTypingHours(value ?? \"\");\n\n  const optionsInterval: [Time, Time] = useMemo(\n    () =>\n      typingHour.match({\n        Some: hour => [\n          maxTime({ hour, minute: 0 }, suggestionStart),\n          minTime({ hour, minute: 59 }, suggestionEnd),\n        ],\n        None: () => [suggestionStart, suggestionEnd],\n      }),\n    [typingHour, suggestionStart, suggestionEnd],\n  );\n\n  const options = useMemo(\n    () =>\n      generateTimeList(optionsInterval[0], optionsInterval[1], intervalInMinutes).slice(\n        0,\n        nbMaxSuggestions,\n      ),\n    [optionsInterval, intervalInMinutes, nbMaxSuggestions],\n  );\n\n  const items = useMemo(() => AsyncData.Done(Result.Ok(options)), [options]);\n\n  return (\n    <Rifm value={value ?? \"\"} onChange={onChangeText} {...rifmTimeProps}>\n      {({ value, onChange }) => (\n        <LakeCombobox\n          keyExtractor={stringifyTime}\n          placeholder=\"HH:MM\"\n          value={value}\n          items={items}\n          itemHeight={40}\n          nbItemsDisplayed={4.5}\n          renderItem={item => {\n            const text = stringifyTime(item);\n            const selected = text === value;\n            const suffix = suggestionSuffix?.(item);\n            const label = isNotNullishOrEmpty(suffix) ? `${text} ${suffix}` : text;\n\n            return (\n              <Box direction=\"row\" alignItems=\"center\">\n                <LakeText\n                  color={selected ? colors.gray[700] : colors.gray[900]}\n                  variant={selected ? \"smallRegular\" : \"medium\"}\n                >\n                  {label}\n                </LakeText>\n\n                <Fill minWidth={8} />\n\n                {selected && (\n                  <Icon name=\"checkmark-filled\" color={colors.positive[500]} size={16} />\n                )}\n              </Box>\n            );\n          }}\n          readOnly={readOnly}\n          disabled={disabled}\n          error={error}\n          hideErrors={hideErrors}\n          emptyResultText={noSuggestionLabel}\n          onChange={onChange}\n          onValueChange={noop}\n          onSelectItem={item => onChangeText(stringifyTime(item))}\n        />\n      )}\n    </Rifm>\n  );\n};\n\nexport type TimeRangePickerProps = {\n  value: { start?: string; end?: string };\n  onChange: (value: { start?: string; end?: string }) => void;\n  intervalInMinutes?: number;\n  nbMaxSuggestions?: number;\n  readOnly?: boolean;\n  disabled?: boolean;\n  error?: string;\n  startLabel: string;\n  endLabel: string;\n  minutesLabel: string;\n  hoursLabel: string;\n  noSuggestionLabel: string;\n};\n\nexport const TimeRangePicker = ({\n  value,\n  onChange,\n  intervalInMinutes = DEFAULT_INTERVAL_IN_MINUTES,\n  nbMaxSuggestions,\n  readOnly,\n  disabled,\n  error,\n  startLabel,\n  endLabel,\n  minutesLabel,\n  hoursLabel,\n  noSuggestionLabel,\n}: TimeRangePickerProps) => {\n  const start = parseTime(value.start ?? \"\");\n\n  const handleStartChange = (startValue: string) => {\n    onChange({\n      start: startValue,\n      end: value.end,\n    });\n  };\n\n  const handleEndChange = (endValue: string) => {\n    onChange({\n      start: value.start,\n      end: endValue,\n    });\n  };\n\n  return (\n    <View>\n      <Box direction=\"row\" alignItems=\"end\">\n        <LakeLabel\n          label={startLabel}\n          style={styles.label}\n          render={() => (\n            <TimePicker\n              value={value.start}\n              intervalInMinutes={intervalInMinutes}\n              nbMaxSuggestions={nbMaxSuggestions}\n              error={error}\n              hideErrors={true}\n              disabled={disabled}\n              readOnly={readOnly}\n              noSuggestionLabel={noSuggestionLabel}\n              onChangeText={handleStartChange}\n            />\n          )}\n        />\n\n        <Space width={12} />\n\n        <Box style={styles.arrowContainer} justifyContent=\"center\">\n          <Icon name=\"arrow-right-filled\" size={20} />\n        </Box>\n\n        <Space width={12} />\n\n        <LakeLabel\n          label={endLabel}\n          style={styles.label}\n          render={() => (\n            <TimePicker\n              value={value.end}\n              intervalInMinutes={intervalInMinutes}\n              nbMaxSuggestions={nbMaxSuggestions}\n              suggestionStart={start\n                .map(time => floorTime(time, intervalInMinutes))\n                .map(time => addMinutes(time, intervalInMinutes))\n                .match({\n                  Some: time => time,\n                  None: () => undefined,\n                })}\n              suggestionSuffix={time => {\n                if (start.isNone()) {\n                  return \"\";\n                }\n                const durationInMinutes = timeToMinutes(time) - timeToMinutes(start.value);\n                if (durationInMinutes > 0 && durationInMinutes <= 60) {\n                  const timeDuration = minutesToTime(durationInMinutes);\n                  return `(${formatTimeDuration(timeDuration, minutesLabel, hoursLabel)})`;\n                }\n                return \"\";\n              }}\n              error={error}\n              hideErrors={true}\n              disabled={disabled}\n              readOnly={readOnly}\n              noSuggestionLabel={noSuggestionLabel}\n              onChangeText={handleEndChange}\n            />\n          )}\n        />\n      </Box>\n\n      <Space height={4} />\n\n      <LakeText variant=\"smallRegular\" color={colors.negative[500]}>\n        {error ?? \" \"}\n      </LakeText>\n    </View>\n  );\n};\n"],"names":["styles","StyleSheet","DEFAULT_START_TIME","DEFAULT_END_TIME","DEFAULT_INTERVAL_IN_MINUTES","rifmTimeProps","getRifmProps","parseTime","time","hours","minutes","isNullish","Option","parseTimeRange","value","start","isNotNullishOrEmpty","end","parseTypingHours","parsedHours","stringifyTime","timeToMinutes","minutesToTime","addMinutes","floorTime","intervalInMinutes","flooredMinutes","validateTime","isTimeBefore","time1","time2","validateTimeRange","range","minTime","times","timesInMinutes","minTimeInMinutes","maxTime","maxTimeInMinutes","generateTimeList","startMinutes","endMinutes","timeList","i","formatTimeDuration","minutesLabel","hoursLabel","TimePicker","onChangeText","suggestionStart","suggestionEnd","nbMaxSuggestions","suggestionSuffix","readOnly","disabled","error","hideErrors","noSuggestionLabel","typingHour","optionsInterval","useMemo","hour","options","items","AsyncData","Result","jsx","Rifm","value2","onChange","LakeCombobox","item","text","selected","suffix","label","jsxs","Box","LakeText","colors","Fill","Icon","noop","TimeRangePicker","startLabel","endLabel","handleStartChange","startValue","handleEndChange","endValue","View","LakeLabel","Space","durationInMinutes","timeDuration"],"mappings":"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"}