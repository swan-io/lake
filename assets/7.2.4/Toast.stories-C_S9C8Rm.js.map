{"version":3,"file":"Toast.stories-C_S9C8Rm.js","sources":["../../../node_modules/@0no-co/graphql.web/dist/graphql.web.mjs","../../../node_modules/@urql/core/dist/urql-core-chunk.mjs","../../../node_modules/react-atomic-state/dist/index.module.js","../../../packages/lake/src/utils/timer.ts","../../../packages/lake/src/state/toasts.ts","../../../packages/lake/src/utils/urql.ts","../../../packages/lake/src/components/ToastStack.tsx"],"sourcesContent":["var e = {\n  NAME: \"Name\",\n  DOCUMENT: \"Document\",\n  OPERATION_DEFINITION: \"OperationDefinition\",\n  VARIABLE_DEFINITION: \"VariableDefinition\",\n  SELECTION_SET: \"SelectionSet\",\n  FIELD: \"Field\",\n  ARGUMENT: \"Argument\",\n  FRAGMENT_SPREAD: \"FragmentSpread\",\n  INLINE_FRAGMENT: \"InlineFragment\",\n  FRAGMENT_DEFINITION: \"FragmentDefinition\",\n  VARIABLE: \"Variable\",\n  INT: \"IntValue\",\n  FLOAT: \"FloatValue\",\n  STRING: \"StringValue\",\n  BOOLEAN: \"BooleanValue\",\n  NULL: \"NullValue\",\n  ENUM: \"EnumValue\",\n  LIST: \"ListValue\",\n  OBJECT: \"ObjectValue\",\n  OBJECT_FIELD: \"ObjectField\",\n  DIRECTIVE: \"Directive\",\n  NAMED_TYPE: \"NamedType\",\n  LIST_TYPE: \"ListType\",\n  NON_NULL_TYPE: \"NonNullType\"\n};\n\nvar r = {\n  QUERY: \"query\",\n  MUTATION: \"mutation\",\n  SUBSCRIPTION: \"subscription\"\n};\n\nclass GraphQLError extends Error {\n  constructor(e, r, i, n, a, t, o) {\n    super(e);\n    this.name = \"GraphQLError\";\n    this.message = e;\n    if (a) {\n      this.path = a;\n    }\n    if (r) {\n      this.nodes = Array.isArray(r) ? r : [ r ];\n    }\n    if (i) {\n      this.source = i;\n    }\n    if (n) {\n      this.positions = n;\n    }\n    if (t) {\n      this.originalError = t;\n    }\n    var l = o;\n    if (!l && t) {\n      var u = t.extensions;\n      if (u && \"object\" == typeof u) {\n        l = u;\n      }\n    }\n    this.extensions = l || {};\n  }\n  toJSON() {\n    return {\n      ...this,\n      message: this.message\n    };\n  }\n  toString() {\n    return this.message;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLError\";\n  }\n}\n\nvar i;\n\nvar n;\n\nfunction error(e) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${n} in ${e}`);\n}\n\nfunction advance(e) {\n  e.lastIndex = n;\n  if (e.test(i)) {\n    return i.slice(n, n = e.lastIndex);\n  }\n}\n\nvar a = / +(?=[^\\s])/y;\n\nfunction blockString(e) {\n  var r = e.split(\"\\n\");\n  var i = \"\";\n  var n = 0;\n  var t = 0;\n  var o = r.length - 1;\n  for (var l = 0; l < r.length; l++) {\n    a.lastIndex = 0;\n    if (a.test(r[l])) {\n      if (l && (!n || a.lastIndex < n)) {\n        n = a.lastIndex;\n      }\n      t = t || l;\n      o = l;\n    }\n  }\n  for (var u = t; u <= o; u++) {\n    if (u !== t) {\n      i += \"\\n\";\n    }\n    i += r[u].slice(n).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return i;\n}\n\nfunction ignored() {\n  for (var e = 0 | i.charCodeAt(n++); 9 === e || 10 === e || 13 === e || 32 === e || 35 === e || 44 === e || 65279 === e; e = 0 | i.charCodeAt(n++)) {\n    if (35 === e) {\n      while (10 !== (e = i.charCodeAt(n++)) && 13 !== e) {}\n    }\n  }\n  n--;\n}\n\nvar t = /[_A-Za-z]\\w*/y;\n\nfunction name() {\n  var e;\n  if (e = advance(t)) {\n    return {\n      kind: \"Name\",\n      value: e\n    };\n  }\n}\n\nvar o = /(?:null|true|false)/y;\n\nvar l = /\\$[_A-Za-z]\\w*/y;\n\nvar u = /-?\\d+/y;\n\nvar v = /(?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+/y;\n\nvar d = /\\\\/g;\n\nvar s = /\"\"\"(?:\"\"\"|(?:[\\s\\S]*?[^\\\\])\"\"\")/y;\n\nvar c = /\"(?:\"|[^\\r\\n]*?[^\\\\]\")/y;\n\nfunction value(e) {\n  var r;\n  var a;\n  if (a = advance(o)) {\n    r = \"null\" === a ? {\n      kind: \"NullValue\"\n    } : {\n      kind: \"BooleanValue\",\n      value: \"true\" === a\n    };\n  } else if (!e && (a = advance(l))) {\n    r = {\n      kind: \"Variable\",\n      name: {\n        kind: \"Name\",\n        value: a.slice(1)\n      }\n    };\n  } else if (a = advance(u)) {\n    var f = a;\n    if (a = advance(v)) {\n      r = {\n        kind: \"FloatValue\",\n        value: f + a\n      };\n    } else {\n      r = {\n        kind: \"IntValue\",\n        value: f\n      };\n    }\n  } else if (a = advance(t)) {\n    r = {\n      kind: \"EnumValue\",\n      value: a\n    };\n  } else if (a = advance(s)) {\n    r = {\n      kind: \"StringValue\",\n      value: blockString(a.slice(3, -3)),\n      block: !0\n    };\n  } else if (a = advance(c)) {\n    r = {\n      kind: \"StringValue\",\n      value: d.test(a) ? JSON.parse(a) : a.slice(1, -1),\n      block: !1\n    };\n  } else if (r = function list(e) {\n    var r;\n    if (91 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      var a = [];\n      while (r = value(e)) {\n        a.push(r);\n      }\n      if (93 !== i.charCodeAt(n++)) {\n        throw error(\"ListValue\");\n      }\n      ignored();\n      return {\n        kind: \"ListValue\",\n        values: a\n      };\n    }\n  }(e) || function object(e) {\n    if (123 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      var r = [];\n      var a;\n      while (a = name()) {\n        ignored();\n        if (58 !== i.charCodeAt(n++)) {\n          throw error(\"ObjectField\");\n        }\n        ignored();\n        var t = value(e);\n        if (!t) {\n          throw error(\"ObjectField\");\n        }\n        r.push({\n          kind: \"ObjectField\",\n          name: a,\n          value: t\n        });\n      }\n      if (125 !== i.charCodeAt(n++)) {\n        throw error(\"ObjectValue\");\n      }\n      ignored();\n      return {\n        kind: \"ObjectValue\",\n        fields: r\n      };\n    }\n  }(e)) {\n    return r;\n  }\n  ignored();\n  return r;\n}\n\nfunction arguments_(e) {\n  var r = [];\n  ignored();\n  if (40 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var a;\n    while (a = name()) {\n      ignored();\n      if (58 !== i.charCodeAt(n++)) {\n        throw error(\"Argument\");\n      }\n      ignored();\n      var t = value(e);\n      if (!t) {\n        throw error(\"Argument\");\n      }\n      r.push({\n        kind: \"Argument\",\n        name: a,\n        value: t\n      });\n    }\n    if (!r.length || 41 !== i.charCodeAt(n++)) {\n      throw error(\"Argument\");\n    }\n    ignored();\n  }\n  return r;\n}\n\nfunction directives(e) {\n  var r = [];\n  ignored();\n  while (64 === i.charCodeAt(n)) {\n    n++;\n    var a = name();\n    if (!a) {\n      throw error(\"Directive\");\n    }\n    ignored();\n    r.push({\n      kind: \"Directive\",\n      name: a,\n      arguments: arguments_(e)\n    });\n  }\n  return r;\n}\n\nfunction field() {\n  var e = name();\n  if (e) {\n    ignored();\n    var r;\n    if (58 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      r = e;\n      if (!(e = name())) {\n        throw error(\"Field\");\n      }\n      ignored();\n    }\n    return {\n      kind: \"Field\",\n      alias: r,\n      name: e,\n      arguments: arguments_(!1),\n      directives: directives(!1),\n      selectionSet: selectionSet()\n    };\n  }\n}\n\nfunction type() {\n  var e;\n  ignored();\n  if (91 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var r = type();\n    if (!r || 93 !== i.charCodeAt(n++)) {\n      throw error(\"ListType\");\n    }\n    e = {\n      kind: \"ListType\",\n      type: r\n    };\n  } else if (e = name()) {\n    e = {\n      kind: \"NamedType\",\n      name: e\n    };\n  } else {\n    throw error(\"NamedType\");\n  }\n  ignored();\n  if (33 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    return {\n      kind: \"NonNullType\",\n      type: e\n    };\n  } else {\n    return e;\n  }\n}\n\nvar f = /on/y;\n\nfunction typeCondition() {\n  if (advance(f)) {\n    ignored();\n    var e = name();\n    if (!e) {\n      throw error(\"NamedType\");\n    }\n    ignored();\n    return {\n      kind: \"NamedType\",\n      name: e\n    };\n  }\n}\n\nvar p = /\\.\\.\\./y;\n\nfunction fragmentSpread() {\n  if (advance(p)) {\n    ignored();\n    var e = n;\n    var r;\n    if ((r = name()) && \"on\" !== r.value) {\n      return {\n        kind: \"FragmentSpread\",\n        name: r,\n        directives: directives(!1)\n      };\n    } else {\n      n = e;\n      var i = typeCondition();\n      var a = directives(!1);\n      var t = selectionSet();\n      if (!t) {\n        throw error(\"InlineFragment\");\n      }\n      return {\n        kind: \"InlineFragment\",\n        typeCondition: i,\n        directives: a,\n        selectionSet: t\n      };\n    }\n  }\n}\n\nfunction selectionSet() {\n  var e;\n  ignored();\n  if (123 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var r = [];\n    while (e = fragmentSpread() || field()) {\n      r.push(e);\n    }\n    if (!r.length || 125 !== i.charCodeAt(n++)) {\n      throw error(\"SelectionSet\");\n    }\n    ignored();\n    return {\n      kind: \"SelectionSet\",\n      selections: r\n    };\n  }\n}\n\nvar m = /fragment/y;\n\nfunction fragmentDefinition() {\n  if (advance(m)) {\n    ignored();\n    var e = name();\n    if (!e) {\n      throw error(\"FragmentDefinition\");\n    }\n    ignored();\n    var r = typeCondition();\n    if (!r) {\n      throw error(\"FragmentDefinition\");\n    }\n    var i = directives(!1);\n    var n = selectionSet();\n    if (!n) {\n      throw error(\"FragmentDefinition\");\n    }\n    return {\n      kind: \"FragmentDefinition\",\n      name: e,\n      typeCondition: r,\n      directives: i,\n      selectionSet: n\n    };\n  }\n}\n\nvar g = /(?:query|mutation|subscription)/y;\n\nfunction operationDefinition() {\n  var e;\n  var r;\n  var a = [];\n  var t = [];\n  if (e = advance(g)) {\n    ignored();\n    r = name();\n    a = function variableDefinitions() {\n      var e;\n      var r = [];\n      ignored();\n      if (40 === i.charCodeAt(n)) {\n        n++;\n        ignored();\n        while (e = advance(l)) {\n          ignored();\n          if (58 !== i.charCodeAt(n++)) {\n            throw error(\"VariableDefinition\");\n          }\n          var a = type();\n          var t = void 0;\n          if (61 === i.charCodeAt(n)) {\n            n++;\n            ignored();\n            if (!(t = value(!0))) {\n              throw error(\"VariableDefinition\");\n            }\n          }\n          ignored();\n          r.push({\n            kind: \"VariableDefinition\",\n            variable: {\n              kind: \"Variable\",\n              name: {\n                kind: \"Name\",\n                value: e.slice(1)\n              }\n            },\n            type: a,\n            defaultValue: t,\n            directives: directives(!0)\n          });\n        }\n        if (41 !== i.charCodeAt(n++)) {\n          throw error(\"VariableDefinition\");\n        }\n        ignored();\n      }\n      return r;\n    }();\n    t = directives(!1);\n  }\n  var o = selectionSet();\n  if (o) {\n    return {\n      kind: \"OperationDefinition\",\n      operation: e || \"query\",\n      name: r,\n      variableDefinitions: a,\n      directives: t,\n      selectionSet: o\n    };\n  }\n}\n\nfunction parse(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return function document() {\n    var e;\n    ignored();\n    var r = [];\n    while (e = fragmentDefinition() || operationDefinition()) {\n      r.push(e);\n    }\n    return {\n      kind: \"Document\",\n      definitions: r\n    };\n  }();\n}\n\nfunction parseValue(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  ignored();\n  var a = value(!1);\n  if (!a) {\n    throw error(\"ValueNode\");\n  }\n  return a;\n}\n\nfunction parseType(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return type();\n}\n\nvar h = {};\n\nfunction visit(e, r) {\n  var i = [];\n  var n = [];\n  try {\n    var a = function traverse(e, a, t) {\n      var o = !1;\n      var l = r[e.kind] && r[e.kind].enter || r[e.kind] || r.enter;\n      var u = l && l.call(r, e, a, t, n, i);\n      if (!1 === u) {\n        return e;\n      } else if (null === u) {\n        return null;\n      } else if (u === h) {\n        throw h;\n      } else if (u && \"string\" == typeof u.kind) {\n        o = u !== e;\n        e = u;\n      }\n      if (t) {\n        i.push(t);\n      }\n      var v;\n      var d = {\n        ...e\n      };\n      for (var s in e) {\n        n.push(s);\n        var c = e[s];\n        if (Array.isArray(c)) {\n          var f = [];\n          for (var p = 0; p < c.length; p++) {\n            if (null != c[p] && \"string\" == typeof c[p].kind) {\n              i.push(e);\n              n.push(p);\n              v = traverse(c[p], p, c);\n              n.pop();\n              i.pop();\n              if (null == v) {\n                o = !0;\n              } else {\n                o = o || v !== c[p];\n                f.push(v);\n              }\n            }\n          }\n          c = f;\n        } else if (null != c && \"string\" == typeof c.kind) {\n          if (void 0 !== (v = traverse(c, s, e))) {\n            o = o || c !== v;\n            c = v;\n          }\n        }\n        n.pop();\n        if (o) {\n          d[s] = c;\n        }\n      }\n      if (t) {\n        i.pop();\n      }\n      var m = r[e.kind] && r[e.kind].leave || r.leave;\n      var g = m && m.call(r, e, a, t, n, i);\n      if (g === h) {\n        throw h;\n      } else if (void 0 !== g) {\n        return g;\n      } else if (void 0 !== u) {\n        return o ? d : u;\n      } else {\n        return o ? d : e;\n      }\n    }(e);\n    return void 0 !== a && !1 !== a ? a : e;\n  } catch (r) {\n    if (r !== h) {\n      throw r;\n    }\n    return e;\n  }\n}\n\nfunction printString(e) {\n  return JSON.stringify(e);\n}\n\nfunction printBlockString(e) {\n  return '\"\"\"\\n' + e.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nvar hasItems = e => !(!e || !e.length);\n\nvar y = {\n  OperationDefinition(e) {\n    if (\"query\" === e.operation && !e.name && !hasItems(e.variableDefinitions) && !hasItems(e.directives)) {\n      return y.SelectionSet(e.selectionSet);\n    }\n    var r = e.operation;\n    if (e.name) {\n      r += \" \" + e.name.value;\n    }\n    if (hasItems(e.variableDefinitions)) {\n      if (!e.name) {\n        r += \" \";\n      }\n      r += \"(\" + e.variableDefinitions.map(y.VariableDefinition).join(\", \") + \")\";\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + y.SelectionSet(e.selectionSet);\n  },\n  VariableDefinition(e) {\n    var r = y.Variable(e.variable) + \": \" + print(e.type);\n    if (e.defaultValue) {\n      r += \" = \" + print(e.defaultValue);\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r;\n  },\n  Field(e) {\n    var r = (e.alias ? e.alias.value + \": \" : \"\") + e.name.value;\n    if (hasItems(e.arguments)) {\n      var i = e.arguments.map(y.Argument);\n      var n = r + \"(\" + i.join(\", \") + \")\";\n      r = n.length > 80 ? r + \"(\\n  \" + i.join(\"\\n\").replace(/\\n/g, \"\\n  \") + \"\\n)\" : n;\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return e.selectionSet ? r + \" \" + y.SelectionSet(e.selectionSet) : r;\n  },\n  StringValue: e => e.block ? printBlockString(e.value) : printString(e.value),\n  BooleanValue: e => \"\" + e.value,\n  NullValue: e => \"null\",\n  IntValue: e => e.value,\n  FloatValue: e => e.value,\n  EnumValue: e => e.value,\n  Name: e => e.value,\n  Variable: e => \"$\" + e.name.value,\n  ListValue: e => \"[\" + e.values.map(print).join(\", \") + \"]\",\n  ObjectValue: e => \"{\" + e.fields.map(y.ObjectField).join(\", \") + \"}\",\n  ObjectField: e => e.name.value + \": \" + print(e.value),\n  Document: e => hasItems(e.definitions) ? e.definitions.map(print).join(\"\\n\\n\") : \"\",\n  SelectionSet: e => \"{\\n  \" + e.selections.map(print).join(\"\\n\").replace(/\\n/g, \"\\n  \") + \"\\n}\",\n  Argument: e => e.name.value + \": \" + print(e.value),\n  FragmentSpread(e) {\n    var r = \"...\" + e.name.value;\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r;\n  },\n  InlineFragment(e) {\n    var r = \"...\";\n    if (e.typeCondition) {\n      r += \" on \" + e.typeCondition.name.value;\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + print(e.selectionSet);\n  },\n  FragmentDefinition(e) {\n    var r = \"fragment \" + e.name.value;\n    r += \" on \" + e.typeCondition.name.value;\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + print(e.selectionSet);\n  },\n  Directive(e) {\n    var r = \"@\" + e.name.value;\n    if (hasItems(e.arguments)) {\n      r += \"(\" + e.arguments.map(y.Argument).join(\", \") + \")\";\n    }\n    return r;\n  },\n  NamedType: e => e.name.value,\n  ListType: e => \"[\" + print(e.type) + \"]\",\n  NonNullType: e => print(e.type) + \"!\"\n};\n\nfunction print(e) {\n  return y[e.kind] ? y[e.kind](e) : \"\";\n}\n\nfunction valueFromASTUntyped(e, r) {\n  switch (e.kind) {\n   case \"NullValue\":\n    return null;\n\n   case \"IntValue\":\n    return parseInt(e.value, 10);\n\n   case \"FloatValue\":\n    return parseFloat(e.value);\n\n   case \"StringValue\":\n   case \"EnumValue\":\n   case \"BooleanValue\":\n    return e.value;\n\n   case \"ListValue\":\n    var i = [];\n    for (var n = 0, a = e.values; n < a.length; n += 1) {\n      i.push(valueFromASTUntyped(a[n], r));\n    }\n    return i;\n\n   case \"ObjectValue\":\n    var t = Object.create(null);\n    for (var o = 0, l = e.fields; o < l.length; o += 1) {\n      var u = l[o];\n      t[u.name.value] = valueFromASTUntyped(u.value, r);\n    }\n    return t;\n\n   case \"Variable\":\n    return r && r[e.name.value];\n  }\n}\n\nfunction valueFromTypeNode(e, r, i) {\n  if (\"Variable\" === e.kind) {\n    return i ? valueFromTypeNode(i[e.name.value], r, i) : void 0;\n  } else if (\"NonNullType\" === r.kind) {\n    return \"NullValue\" !== e.kind ? valueFromTypeNode(e, r, i) : void 0;\n  } else if (\"NullValue\" === e.kind) {\n    return null;\n  } else if (\"ListType\" === r.kind) {\n    if (\"ListValue\" === e.kind) {\n      var n = [];\n      for (var a = 0, t = e.values; a < t.length; a += 1) {\n        var o = valueFromTypeNode(t[a], r.type, i);\n        if (void 0 === o) {\n          return;\n        } else {\n          n.push(o);\n        }\n      }\n      return n;\n    }\n  } else if (\"NamedType\" === r.kind) {\n    switch (r.name.value) {\n     case \"Int\":\n     case \"Float\":\n     case \"String\":\n     case \"Bool\":\n      return r.name.value + \"Value\" === e.kind ? valueFromASTUntyped(e, i) : void 0;\n\n     default:\n      return valueFromASTUntyped(e, i);\n    }\n  }\n}\n\nexport { h as BREAK, GraphQLError, e as Kind, r as OperationTypeNode, parse, parseType, parseValue, print, printBlockString, printString, valueFromASTUntyped, valueFromTypeNode, visit };\n//# sourceMappingURL=graphql.web.mjs.map\n","import { GraphQLError as e, print as r, parse as t, Kind as a } from \"@0no-co/graphql.web\";\n\nimport { onEnd as o, filter as n, fromAsyncIterable as s } from \"wonka\";\n\nvar rehydrateGraphQlError = r => {\n  if (r && r.message && (r.extensions || \"GraphQLError\" === r.name)) {\n    return r;\n  } else if (\"object\" == typeof r && r.message) {\n    return new e(r.message, r.nodes, r.source, r.positions, r.path, r, r.extensions || {});\n  } else {\n    return new e(r);\n  }\n};\n\nclass CombinedError extends Error {\n  constructor(e) {\n    var r = (e.graphQLErrors || []).map(rehydrateGraphQlError);\n    var t = ((e, r) => {\n      var t = \"\";\n      if (e) {\n        return `[Network] ${e.message}`;\n      }\n      if (r) {\n        for (var a of r) {\n          if (t) {\n            t += \"\\n\";\n          }\n          t += `[GraphQL] ${a.message}`;\n        }\n      }\n      return t;\n    })(e.networkError, r);\n    super(t);\n    this.name = \"CombinedError\";\n    this.message = t;\n    this.graphQLErrors = r;\n    this.networkError = e.networkError;\n    this.response = e.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\n\nvar phash = (e, r) => {\n  var t = 0 | (r || 5381);\n  for (var a = 0, o = 0 | e.length; a < o; a++) {\n    t = (t << 5) + t + e.charCodeAt(a);\n  }\n  return t;\n};\n\nvar i = new Set;\n\nvar f = new WeakMap;\n\nvar stringify = e => {\n  if (null === e || i.has(e)) {\n    return \"null\";\n  } else if (\"object\" != typeof e) {\n    return JSON.stringify(e) || \"\";\n  } else if (e.toJSON) {\n    return stringify(e.toJSON());\n  } else if (Array.isArray(e)) {\n    var r = \"[\";\n    for (var t of e) {\n      if (r.length > 1) {\n        r += \",\";\n      }\n      r += stringify(t) || \"null\";\n    }\n    return r += \"]\";\n  } else if (l !== NoopConstructor && e instanceof l || c !== NoopConstructor && e instanceof c) {\n    return \"null\";\n  }\n  var a = Object.keys(e).sort();\n  if (!a.length && e.constructor && Object.getPrototypeOf(e).constructor !== Object.prototype.constructor) {\n    var o = f.get(e) || Math.random().toString(36).slice(2);\n    f.set(e, o);\n    return stringify({\n      __key: o\n    });\n  }\n  i.add(e);\n  var n = \"{\";\n  for (var s of a) {\n    var d = stringify(e[s]);\n    if (d) {\n      if (n.length > 1) {\n        n += \",\";\n      }\n      n += stringify(s) + \":\" + d;\n    }\n  }\n  i.delete(e);\n  return n += \"}\";\n};\n\nvar extract = (e, r, t) => {\n  if (null == t || \"object\" != typeof t || t.toJSON || i.has(t)) {} else if (Array.isArray(t)) {\n    for (var a = 0, o = t.length; a < o; a++) {\n      extract(e, `${r}.${a}`, t[a]);\n    }\n  } else if (t instanceof l || t instanceof c) {\n    e.set(r, t);\n  } else {\n    i.add(t);\n    for (var n of Object.keys(t)) {\n      extract(e, `${r}.${n}`, t[n]);\n    }\n  }\n};\n\nvar stringifyVariables = e => {\n  i.clear();\n  return stringify(e);\n};\n\nclass NoopConstructor {}\n\nvar l = \"undefined\" != typeof File ? File : NoopConstructor;\n\nvar c = \"undefined\" != typeof Blob ? Blob : NoopConstructor;\n\nvar d = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\n\nvar v = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\n\nvar replaceOutsideStrings = (e, r) => r % 2 == 0 ? e.replace(v, \"\\n\") : e;\n\nvar sanitizeDocument = e => e.split(d).map(replaceOutsideStrings).join(\"\").trim();\n\nvar p = new Map;\n\nvar u = new Map;\n\nvar stringifyDocument = e => {\n  var t;\n  if (\"string\" == typeof e) {\n    t = sanitizeDocument(e);\n  } else if (e.loc && u.get(e.__key) === e) {\n    t = e.loc.source.body;\n  } else {\n    t = p.get(e) || sanitizeDocument(r(e));\n    p.set(e, t);\n  }\n  if (\"string\" != typeof e && !e.loc) {\n    e.loc = {\n      start: 0,\n      end: t.length,\n      source: {\n        body: t,\n        name: \"gql\",\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return t;\n};\n\nvar hashDocument = e => {\n  var r = phash(stringifyDocument(e));\n  if (e.definitions) {\n    var t = getOperationName(e);\n    if (t) {\n      r = phash(`\\n# ${t}`, r);\n    }\n  }\n  return r;\n};\n\nvar keyDocument = e => {\n  var r;\n  var a;\n  if (\"string\" == typeof e) {\n    r = hashDocument(e);\n    a = u.get(r) || t(e, {\n      noLocation: !0\n    });\n  } else {\n    r = e.__key || hashDocument(e);\n    a = u.get(r) || e;\n  }\n  if (!a.loc) {\n    stringifyDocument(a);\n  }\n  a.__key = r;\n  u.set(r, a);\n  return a;\n};\n\nvar createRequest = (e, r, t) => {\n  var a = r || {};\n  var o = keyDocument(e);\n  var n = stringifyVariables(a);\n  var s = o.__key;\n  if (\"{}\" !== n) {\n    s = phash(n, s);\n  }\n  return {\n    key: s,\n    query: o,\n    variables: a,\n    extensions: t\n  };\n};\n\nvar getOperationName = e => {\n  for (var r of e.definitions) {\n    if (r.kind === a.OPERATION_DEFINITION) {\n      return r.name ? r.name.value : void 0;\n    }\n  }\n};\n\nvar getOperationType = e => {\n  for (var r of e.definitions) {\n    if (r.kind === a.OPERATION_DEFINITION) {\n      return r.operation;\n    }\n  }\n};\n\nvar makeResult = (e, r, t) => {\n  if (!(\"data\" in r || \"errors\" in r && Array.isArray(r.errors))) {\n    throw new Error(\"No Content\");\n  }\n  var a = \"subscription\" === e.kind;\n  return {\n    operation: e,\n    data: r.data,\n    error: Array.isArray(r.errors) ? new CombinedError({\n      graphQLErrors: r.errors,\n      response: t\n    }) : void 0,\n    extensions: r.extensions ? {\n      ...r.extensions\n    } : void 0,\n    hasNext: null == r.hasNext ? a : r.hasNext,\n    stale: !1\n  };\n};\n\nvar deepMerge = (e, r) => {\n  if (\"object\" == typeof e && null != e) {\n    if (!e.constructor || e.constructor === Object || Array.isArray(e)) {\n      e = Array.isArray(e) ? [ ...e ] : {\n        ...e\n      };\n      for (var t of Object.keys(r)) {\n        e[t] = deepMerge(e[t], r[t]);\n      }\n      return e;\n    }\n  }\n  return r;\n};\n\nvar mergeResultPatch = (e, r, t, a) => {\n  var o = e.error ? e.error.graphQLErrors : [];\n  var n = !!e.extensions || !!(r.payload || r).extensions;\n  var s = {\n    ...e.extensions,\n    ...(r.payload || r).extensions\n  };\n  var i = r.incremental;\n  if (\"path\" in r) {\n    i = [ r ];\n  }\n  var f = {\n    data: e.data\n  };\n  if (i) {\n    var _loop = function(e) {\n      if (Array.isArray(e.errors)) {\n        o.push(...e.errors);\n      }\n      if (e.extensions) {\n        Object.assign(s, e.extensions);\n        n = !0;\n      }\n      var r = \"data\";\n      var t = f;\n      var i = [];\n      if (e.path) {\n        i = e.path;\n      } else if (a) {\n        var l = a.find((r => r.id === e.id));\n        if (e.subPath) {\n          i = [ ...l.path, ...e.subPath ];\n        } else {\n          i = l.path;\n        }\n      }\n      for (var c = 0, d = i.length; c < d; r = i[c++]) {\n        t = t[r] = Array.isArray(t[r]) ? [ ...t[r] ] : {\n          ...t[r]\n        };\n      }\n      if (e.items) {\n        var v = +r >= 0 ? r : 0;\n        for (var p = 0, u = e.items.length; p < u; p++) {\n          t[v + p] = deepMerge(t[v + p], e.items[p]);\n        }\n      } else if (void 0 !== e.data) {\n        t[r] = deepMerge(t[r], e.data);\n      }\n    };\n    for (var l of i) {\n      _loop(l);\n    }\n  } else {\n    f.data = (r.payload || r).data || e.data;\n    o = r.errors || r.payload && r.payload.errors || o;\n  }\n  return {\n    operation: e.operation,\n    data: f.data,\n    error: o.length ? new CombinedError({\n      graphQLErrors: o,\n      response: t\n    }) : void 0,\n    extensions: n ? s : void 0,\n    hasNext: null != r.hasNext ? r.hasNext : e.hasNext,\n    stale: !1\n  };\n};\n\nvar makeErrorResult = (e, r, t) => ({\n  operation: e,\n  data: void 0,\n  error: new CombinedError({\n    networkError: r,\n    response: t\n  }),\n  extensions: void 0,\n  hasNext: !1,\n  stale: !1\n});\n\nfunction makeFetchBody(e) {\n  var r = {\n    query: void 0,\n    documentId: void 0,\n    operationName: getOperationName(e.query),\n    variables: e.variables || void 0,\n    extensions: e.extensions\n  };\n  if (\"documentId\" in e.query && e.query.documentId && (!e.query.definitions || !e.query.definitions.length)) {\n    r.documentId = e.query.documentId;\n  } else if (!e.extensions || !e.extensions.persistedQuery || e.extensions.persistedQuery.miss) {\n    r.query = stringifyDocument(e.query);\n  }\n  return r;\n}\n\nvar makeFetchURL = (e, r) => {\n  var t = \"query\" === e.kind && e.context.preferGetMethod;\n  if (!t || !r) {\n    return e.context.url;\n  }\n  var a = splitOutSearchParams(e.context.url);\n  for (var o in r) {\n    var n = r[o];\n    if (n) {\n      a[1].set(o, \"object\" == typeof n ? stringifyVariables(n) : n);\n    }\n  }\n  var s = a.join(\"?\");\n  if (s.length > 2047 && \"force\" !== t) {\n    e.context.preferGetMethod = !1;\n    return e.context.url;\n  }\n  return s;\n};\n\nvar splitOutSearchParams = e => {\n  var r = e.indexOf(\"?\");\n  return r > -1 ? [ e.slice(0, r), new URLSearchParams(e.slice(r + 1)) ] : [ e, new URLSearchParams ];\n};\n\nvar serializeBody = (e, r) => {\n  if (r && !(\"query\" === e.kind && !!e.context.preferGetMethod)) {\n    var t = stringifyVariables(r);\n    var a = (e => {\n      var r = new Map;\n      if (l !== NoopConstructor || c !== NoopConstructor) {\n        i.clear();\n        extract(r, \"variables\", e);\n      }\n      return r;\n    })(r.variables);\n    if (a.size) {\n      var o = new FormData;\n      o.append(\"operations\", t);\n      o.append(\"map\", stringifyVariables({\n        ...[ ...a.keys() ].map((e => [ e ]))\n      }));\n      var n = 0;\n      for (var s of a.values()) {\n        o.append(\"\" + n++, s);\n      }\n      return o;\n    }\n    return t;\n  }\n};\n\nvar makeFetchOptions = (e, r) => {\n  var t = {\n    accept: \"subscription\" === e.kind ? \"text/event-stream, multipart/mixed\" : \"application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed\"\n  };\n  var a = (\"function\" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions) || {};\n  if (a.headers) {\n    if ((e => \"has\" in e && !Object.keys(e).length)(a.headers)) {\n      a.headers.forEach(((e, r) => {\n        t[r] = e;\n      }));\n    } else if (Array.isArray(a.headers)) {\n      a.headers.forEach(((e, r) => {\n        if (Array.isArray(e)) {\n          if (t[e[0]]) {\n            t[e[0]] = `${t[e[0]]},${e[1]}`;\n          } else {\n            t[e[0]] = e[1];\n          }\n        } else {\n          t[r] = e;\n        }\n      }));\n    } else {\n      for (var o in a.headers) {\n        t[o.toLowerCase()] = a.headers[o];\n      }\n    }\n  }\n  var n = serializeBody(e, r);\n  if (\"string\" == typeof n && !t[\"content-type\"]) {\n    t[\"content-type\"] = \"application/json\";\n  }\n  return {\n    ...a,\n    method: n ? \"POST\" : \"GET\",\n    body: n,\n    headers: t\n  };\n};\n\nvar y = \"undefined\" != typeof TextDecoder ? new TextDecoder : null;\n\nvar h = /boundary=\"?([^=\";]+)\"?/i;\n\nvar m = /data: ?([^\\n]+)/;\n\nvar toString = e => \"Buffer\" === e.constructor.name ? e.toString() : y.decode(e);\n\nasync function* streamBody(e) {\n  if (e.body[Symbol.asyncIterator]) {\n    for await (var r of e.body) {\n      yield toString(r);\n    }\n  } else {\n    var t = e.body.getReader();\n    var a;\n    try {\n      while (!(a = await t.read()).done) {\n        yield toString(a.value);\n      }\n    } finally {\n      t.cancel();\n    }\n  }\n}\n\nasync function* split(e, r) {\n  var t = \"\";\n  var a;\n  for await (var o of e) {\n    t += o;\n    while ((a = t.indexOf(r)) > -1) {\n      yield t.slice(0, a);\n      t = t.slice(a + r.length);\n    }\n  }\n}\n\nasync function* fetchOperation(e, r, t) {\n  var a = !0;\n  var o = null;\n  var n;\n  try {\n    yield await Promise.resolve();\n    var s = (n = await (e.context.fetch || fetch)(r, t)).headers.get(\"Content-Type\") || \"\";\n    var i;\n    if (/multipart\\/mixed/i.test(s)) {\n      i = async function* parseMultipartMixed(e, r) {\n        var t = e.match(h);\n        var a = \"--\" + (t ? t[1] : \"-\");\n        var o = !0;\n        var n;\n        for await (var s of split(streamBody(r), \"\\r\\n\" + a)) {\n          if (o) {\n            o = !1;\n            var i = s.indexOf(a);\n            if (i > -1) {\n              s = s.slice(i + a.length);\n            } else {\n              continue;\n            }\n          }\n          try {\n            yield n = JSON.parse(s.slice(s.indexOf(\"\\r\\n\\r\\n\") + 4));\n          } catch (e) {\n            if (!n) {\n              throw e;\n            }\n          }\n          if (n && !1 === n.hasNext) {\n            break;\n          }\n        }\n        if (n && !1 !== n.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(s, n);\n    } else if (/text\\/event-stream/i.test(s)) {\n      i = async function* parseEventStream(e) {\n        var r;\n        for await (var t of split(streamBody(e), \"\\n\\n\")) {\n          var a = t.match(m);\n          if (a) {\n            var o = a[1];\n            try {\n              yield r = JSON.parse(o);\n            } catch (e) {\n              if (!r) {\n                throw e;\n              }\n            }\n            if (r && !1 === r.hasNext) {\n              break;\n            }\n          }\n        }\n        if (r && !1 !== r.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(n);\n    } else if (!/text\\//i.test(s)) {\n      i = async function* parseJSON(e) {\n        yield JSON.parse(await e.text());\n      }(n);\n    } else {\n      i = async function* parseMaybeJSON(e) {\n        var r = await e.text();\n        try {\n          var t = JSON.parse(r);\n          if (\"production\" !== process.env.NODE_ENV) {\n            console.warn('Found response with content-type \"text/plain\" but it had a valid \"application/json\" response.');\n          }\n          yield t;\n        } catch (e) {\n          throw new Error(r);\n        }\n      }(n);\n    }\n    var f;\n    for await (var l of i) {\n      if (l.pending && !o) {\n        f = l.pending;\n      } else if (l.pending) {\n        f = [ ...f, ...l.pending ];\n      }\n      o = o ? mergeResultPatch(o, l, n, f) : makeResult(e, l, n);\n      a = !1;\n      yield o;\n      a = !0;\n    }\n    if (!o) {\n      yield o = makeResult(e, {}, n);\n    }\n  } catch (r) {\n    if (!a) {\n      throw r;\n    }\n    yield makeErrorResult(e, n && (n.status < 200 || n.status >= 300) && n.statusText ? new Error(n.statusText) : r, n);\n  }\n}\n\nfunction makeFetchSource(e, r, t) {\n  var a;\n  if (\"undefined\" != typeof AbortController) {\n    t.signal = (a = new AbortController).signal;\n  }\n  return o((() => {\n    if (a) {\n      a.abort();\n    }\n  }))(n((e => !!e))(s(fetchOperation(e, r, t))));\n}\n\nexport { CombinedError as C, makeFetchBody as a, makeErrorResult as b, mergeResultPatch as c, makeFetchURL as d, makeFetchOptions as e, makeFetchSource as f, getOperationType as g, createRequest as h, stringifyVariables as i, keyDocument as k, makeResult as m, stringifyDocument as s };\n//# sourceMappingURL=urql-core-chunk.mjs.map\n","import{useSyncExternalStoreWithSelector as e}from\"use-sync-external-store/shim/with-selector\";function t(e){const t=new Set;let r=e;return{get:()=>r,set(e){r=\"function\"==typeof e?e(r):e,t.forEach(e=>e(r))},subscribe:e=>(t.add(e),()=>{t.delete(e)}),reset(){r=e,t.forEach(e=>e(r))}}}function r(e){return e}function n(t,n){return void 0===n&&(n=Object.is),e(t.subscribe,t.get,t.get,r,n)}function o(t,r,n){return void 0===n&&(n=Object.is),e(t.subscribe,t.get,t.get,r,n)}export{t as atom,n as useAtom,o as useAtomWithSelector};\n//# sourceMappingURL=index.module.js.map\n","// based on https://gist.github.com/ncou/3a0a1f89c8e22416d0d607f621a948a9\n\nexport type ControllableTimeout = {\n  readonly duration: number;\n  readonly clear: () => void;\n  readonly reset: () => void;\n};\n\nexport const createControllableTimeout = (config: {\n  duration: number;\n  onStart: (duration: number) => void;\n  onEnd: () => void;\n  onReset: (duration: number) => void;\n}): ControllableTimeout => {\n  const { duration, onStart, onReset, onEnd } = config;\n  let timerId = 0;\n  let remaining = duration;\n\n  const clear = () => {\n    document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    window.clearTimeout(timerId);\n  };\n\n  const start = () => {\n    if (remaining <= 0) {\n      return;\n    }\n\n    timerId = window.setTimeout(() => {\n      remaining = 0;\n      clear();\n      onEnd();\n    }, remaining);\n\n    onStart(duration);\n  };\n\n  const reset = () => {\n    window.clearTimeout(timerId);\n\n    remaining = duration;\n\n    timerId = window.setTimeout(() => {\n      remaining = 0;\n      clear();\n      onEnd();\n    }, duration);\n\n    onReset(duration);\n  };\n\n  const onVisibilityChange = () => {\n    document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    start();\n  };\n\n  if (document.hidden) {\n    document.addEventListener(\"visibilitychange\", onVisibilityChange);\n  } else {\n    start();\n  }\n\n  return {\n    duration,\n    clear,\n    reset,\n  };\n};\n","import { atom, useAtom } from \"react-atomic-state\";\nimport { Animated, Easing } from \"react-native\";\nimport { ControllableTimeout, createControllableTimeout } from \"../utils/timer\";\n\nexport type ToastVariant = \"success\" | \"info\" | \"warning\" | \"error\";\n\ntype ToastContent = {\n  variant: ToastVariant;\n  title: string;\n  description?: string;\n  error?: unknown;\n  autoClose?: boolean;\n};\n\ntype Toast = {\n  uid: string;\n  variant: ToastVariant;\n  title: string;\n  description?: string;\n  error?: unknown;\n  progress?: Animated.Value;\n  timeout?: ControllableTimeout;\n};\n\nconst toasts = atom<Toast[]>([]);\n\nexport const useToasts = () => useAtom(toasts);\n\nexport const hideToast = (uid: string) => {\n  const toast = toasts.get().find(toast => toast.uid === uid);\n\n  if (!toast) {\n    return;\n  }\n\n  toast.timeout?.clear();\n  toast.progress?.stopAnimation();\n\n  toasts.set(toasts => toasts.filter(toast => toast.uid !== uid));\n};\n\nexport const showToast = ({ variant, title, description, error, autoClose }: ToastContent) => {\n  const uid = `${variant} - ${title} - ${description ?? \"\"}`;\n\n  const toast = toasts.get().find(toast => toast.uid === uid);\n\n  if (toast != null) {\n    if (toast.timeout && toast.progress) {\n      toast.timeout.clear();\n\n      Animated.timing(toast.progress, {\n        duration: 100,\n        easing: Easing.linear,\n        toValue: 1,\n        useNativeDriver: false,\n      }).start(() => {\n        toast.timeout?.reset();\n      });\n    }\n\n    return uid;\n  }\n\n  // by default, only info and success toasts are auto-closing\n  const isAutoClosingToast = autoClose ?? (variant === \"info\" || variant === \"success\");\n\n  const progress = isAutoClosingToast ? new Animated.Value(1) : undefined;\n\n  const timeout = progress\n    ? createControllableTimeout({\n        duration: 10000,\n        onStart: duration => {\n          Animated.timing(progress, {\n            duration,\n            easing: Easing.linear,\n            toValue: 0,\n            useNativeDriver: false,\n          }).start();\n        },\n        onReset: duration => {\n          Animated.timing(progress, {\n            duration,\n            easing: Easing.linear,\n            toValue: 0,\n            useNativeDriver: false,\n          }).start();\n        },\n        onEnd: () => {\n          hideToast(uid);\n        },\n      })\n    : undefined;\n\n  toasts.set(toasts => [{ uid, variant, title, description, error, progress, timeout }, ...toasts]);\n  return uid;\n};\n","import { Result } from \"@swan-io/boxed\";\nimport { Except, SetRequired } from \"type-fest\";\nimport {\n  AnyVariables,\n  CombinedError,\n  OperationResult,\n  UseQueryArgs,\n  UseQueryResponse,\n  UseQueryState,\n  useQuery,\n} from \"urql\";\nimport { isNotNullish, isNullish } from \"./nullish\";\n\nexport const isCombinedError = (error: unknown): error is CombinedError =>\n  error instanceof CombinedError;\n\nexport const parseOperationResult = <T>({ error, data }: OperationResult<T>): T => {\n  if (isNotNullish(error)) {\n    throw error;\n  }\n\n  if (isNullish(data)) {\n    throw new CombinedError({\n      networkError: new Error(\"No Content\"),\n    });\n  }\n\n  return data;\n};\n\nexport const useQueryWithErrorBoundary = <\n  Data = unknown,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  options: UseQueryArgs<Variables, Data>,\n): [\n  SetRequired<Except<UseQueryState<Data, Variables>, \"fetching\" | \"error\">, \"data\">,\n  UseQueryResponse[1],\n] => {\n  const [{ fetching, data, error, ...rest }, reexecuteQuery] = useQuery<Data, Variables>(options);\n\n  if (isNotNullish(error)) {\n    throw error;\n  }\n\n  if (isNullish(data)) {\n    throw new CombinedError({\n      networkError: new Error(\"No Content\"),\n    });\n  }\n\n  return [{ data, ...rest }, reexecuteQuery];\n};\n\nexport const filterRejectionsToPromise = <T extends { __typename: string }>(input: T) =>\n  (input.__typename.endsWith(\"Rejection\")\n    ? Promise.reject(new Error(input.__typename))\n    : Promise.resolve(input)) as Promise<Exclude<T, { __typename: `${string}Rejection` }>>;\n\nexport const filterRejectionsToResult = <T extends { __typename: string }>(input: T) =>\n  (input.__typename.endsWith(\"Rejection\") ? Result.Error(input) : Result.Ok(input)) as Result<\n    Exclude<T, { __typename: `${string}Rejection` }>,\n    Extract<T, { __typename: `${string}Rejection` }>\n  >;\n","import { t } from \"@swan-io/shared-business/src/utils/i18n\";\nimport { memo, useEffect, useRef, useState } from \"react\";\nimport { Animated, Clipboard, StyleSheet, View } from \"react-native\";\nimport { match } from \"ts-pattern\";\nimport { ColorVariants, animations, colors, shadows } from \"../constants/design\";\nimport { ToastVariant, hideToast, useToasts } from \"../state/toasts\";\nimport { isNotNullish, isNotNullishOrEmpty, isNullish } from \"../utils/nullish\";\nimport { isCombinedError } from \"../utils/urql\";\nimport { Box } from \"./Box\";\nimport { Icon } from \"./Icon\";\nimport { LakeText } from \"./LakeText\";\nimport { LakeTooltip } from \"./LakeTooltip\";\nimport { Portal } from \"./Portal\";\nimport { Pressable } from \"./Pressable\";\nimport { Space } from \"./Space\";\nimport { TransitionGroupView } from \"./TransitionGroupView\";\n\nconst styles = StyleSheet.create({\n  list: {\n    position: \"absolute\",\n    right: 0,\n    bottom: 0,\n    maxHeight: \"100%\",\n    maxWidth: 400,\n    paddingVertical: 8,\n    width: \"100%\",\n    zIndex: 10,\n  },\n  toastWrapper: {\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n  },\n  toast: {\n    padding: 24,\n    borderRadius: 4,\n    borderWidth: 1,\n    borderLeftWidth: 4,\n    overflow: \"hidden\",\n    boxShadow: shadows.modal,\n  },\n  contentContainer: {\n    paddingRight: 36, // 24 for close button + 12 for spacing\n  },\n  closeButton: {\n    zIndex: 1,\n    position: \"absolute\",\n    width: 24,\n    height: 24,\n    right: 24,\n    top: 0,\n    bottom: 0,\n    margin: \"auto\",\n  },\n  progressBar: {\n    height: 2,\n    transformOrigin: \"left\",\n  },\n  copyTooltip: {\n    alignSelf: \"flex-start\",\n  },\n  copyButton: {\n    alignItems: \"center\",\n    flexDirection: \"row\",\n    flexGrow: 1,\n    flexShrink: 1,\n  },\n});\n\ntype ToastProps = {\n  variant: ToastVariant;\n  uid: string;\n  title: string;\n  description?: string;\n  error?: unknown;\n  progress?: Animated.Value;\n  onClose: (uid: string) => void;\n};\n\nconst Toast = memo<ToastProps>(({ variant, uid, title, description, error, progress, onClose }) => {\n  const progressBarRef = useRef<View>(null);\n  const [visibleState, setVisibleState] = useState<\"copy\" | \"copied\">(\"copy\");\n  const hasDescription = isNotNullishOrEmpty(description);\n\n  const colorVariation = match(variant)\n    .returnType<ColorVariants>()\n    .with(\"success\", () => \"positive\")\n    .with(\"error\", () => \"negative\")\n    .with(\"info\", () => \"shakespear\")\n    .with(\"warning\", () => \"warning\")\n    .exhaustive();\n\n  useEffect(() => {\n    if (isNullish(progress)) {\n      return;\n    }\n\n    const id = progress.addListener(({ value }) => {\n      if (progressBarRef.current instanceof HTMLElement) {\n        progressBarRef.current.style.transform = `scaleX(${value})`;\n      }\n    });\n\n    return () => progress.removeListener(id);\n  }, [progress]);\n\n  return (\n    <View style={styles.toastWrapper}>\n      <View\n        style={[\n          styles.toast,\n          {\n            borderColor: colors[colorVariation][200],\n            borderLeftColor: colors[colorVariation][500],\n            backgroundColor: colors[colorVariation][0],\n          },\n        ]}\n      >\n        <Box style={styles.contentContainer}>\n          <Box direction=\"row\" alignItems=\"center\">\n            {match(variant)\n              .with(\"success\", () => (\n                <Icon\n                  name=\"checkmark-circle-regular\"\n                  size={20}\n                  color={colors[colorVariation][700]}\n                />\n              ))\n              .with(\"error\", () => (\n                <Icon name=\"dismiss-circle-regular\" size={20} color={colors[colorVariation][700]} />\n              ))\n              .with(\"info\", () => (\n                <Icon name=\"info-regular\" size={20} color={colors[colorVariation][700]} />\n              ))\n              .with(\"warning\", () => (\n                <Icon name=\"warning-regular\" size={20} color={colors[colorVariation][700]} />\n              ))\n              .exhaustive()}\n\n            <Space width={12} />\n\n            <LakeText variant=\"regular\" color={colors[colorVariation][700]}>\n              {title}\n            </LakeText>\n          </Box>\n\n          {hasDescription && (\n            <>\n              <Space height={8} />\n\n              <LakeText variant=\"smallRegular\" color={colors.gray[700]}>\n                {description}\n              </LakeText>\n            </>\n          )}\n\n          {isCombinedError(error) && isNotNullish(error.requestId) ? (\n            <>\n              <Space height={hasDescription ? 4 : 8} />\n\n              <LakeTooltip\n                describedBy=\"copy\"\n                onHide={() => setVisibleState(\"copy\")}\n                togglableOnFocus={true}\n                placement=\"center\"\n                containerStyle={styles.copyTooltip}\n                content={\n                  visibleState === \"copy\"\n                    ? t(\"copyButton.copyTooltip\")\n                    : t(\"copyButton.copiedTooltip\")\n                }\n              >\n                <Pressable\n                  style={styles.copyButton}\n                  onPress={event => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    Clipboard.setString(error.requestId ?? \"\");\n                    setVisibleState(\"copied\");\n                  }}\n                >\n                  <Icon color={colors.gray[700]} size={14} name=\"copy-regular\" />\n                  <Space width={4} />\n\n                  <LakeText numberOfLines={1} variant=\"smallRegular\" color={colors.gray[700]}>\n                    ID: {error.requestId}\n                  </LakeText>\n                </Pressable>\n              </LakeTooltip>\n            </>\n          ) : null}\n        </Box>\n\n        <Pressable onPress={() => onClose(uid)} style={styles.closeButton}>\n          <Icon name=\"lake-close\" size={24} color={colors.gray[500]} />\n        </Pressable>\n\n        {progress != null && (\n          <>\n            <Space height={24} />\n\n            <View\n              ref={progressBarRef}\n              role=\"progressbar\"\n              style={[styles.progressBar, { backgroundColor: colors[colorVariation][500] }]}\n            />\n          </>\n        )}\n      </View>\n    </View>\n  );\n});\n\nexport const ToastStack = () => {\n  const toasts = useToasts();\n\n  const [rootElement, setRootElement] = useState<Element | undefined>(() => undefined);\n\n  useEffect(() => {\n    const rootElement = document.createElement(\"div\");\n    document.body.append(rootElement);\n    setRootElement(rootElement);\n    return () => {\n      rootElement.remove();\n      setRootElement(undefined);\n    };\n  }, []);\n\n  if (rootElement == null) {\n    return null;\n  }\n\n  return (\n    <Portal container={rootElement}>\n      <TransitionGroupView\n        style={styles.list}\n        enter={animations.fadeAndSlideInFromRight.enter}\n        leave={animations.fadeAndSlideInFromRight.leave}\n      >\n        {toasts.map(toast => (\n          <Toast\n            key={toast.uid}\n            uid={toast.uid}\n            variant={toast.variant}\n            title={toast.title}\n            description={toast.description}\n            error={toast.error}\n            progress={toast.progress}\n            onClose={hideToast}\n          />\n        ))}\n      </TransitionGroupView>\n    </Portal>\n  );\n};\n"],"names":["GraphQLError","e","r","i","n","a","t","o","u","rehydrateGraphQlError","CombinedError","createControllableTimeout","config","duration","onStart","onReset","onEnd","timerId","remaining","clear","onVisibilityChange","start","reset","toasts","atom","useToasts","useAtom","hideToast","uid","toast","_a","_b","showToast","variant","title","description","error","autoClose","Animated","Easing","progress","timeout","isCombinedError","styles","StyleSheet","shadows","Toast","memo","onClose","progressBarRef","useRef","visibleState","setVisibleState","useState","hasDescription","isNotNullishOrEmpty","colorVariation","match","useEffect","isNullish","id","value","jsx","View","jsxs","colors","Box","Icon","Space","LakeText","Fragment","isNotNullish","LakeTooltip","Pressable","event","Clipboard","ToastStack","rootElement","setRootElement","Portal","TransitionGroupView","animations"],"mappings":"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","x_google_ignoreList":[0,1,2]}