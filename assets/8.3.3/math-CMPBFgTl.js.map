{"version":3,"file":"math-CMPBFgTl.js","sources":["../../../packages/lake/src/utils/math.ts"],"sourcesContent":["import { isNotNullish, isNullish } from \"./nullish\";\n\ntype InterpolateTuple = [number, number, ...number[]];\ntype FixedLength<L extends number> = number[] & { 0: number; length: L };\n\ntype InterpolateParams<T extends InterpolateTuple> = {\n  inputRange: T;\n  outputRange: FixedLength<T[\"length\"]>;\n  clamp?: boolean;\n};\n\nconst getValue = (array: number[], index: number, name: string): number => {\n  const value = array[index];\n  if (isNullish(value)) {\n    throw new Error(`Interpolation Error: index \"${index}\" doesn't exists in ${name}`);\n  }\n  return value;\n};\n\nexport const clampValue =\n  (min: number, max: number) =>\n  (value: number): number =>\n    Math.max(Math.min(value, max), min);\n\n// Here we can disable no-non-null-assertion because this function is called in interpolate which have types checking if there is at least 2 values in range\nconst getRangeIndexes = <T extends InterpolateTuple>(range: T, value: number): [number, number] => {\n  if (value < range[0]) {\n    return [0, 1];\n  }\n\n  const maxIndex = range.length - 1;\n  for (let i = 0; i <= maxIndex; i += 1) {\n    const nextIndex = i + 1;\n    const startRange = getValue(range, i, \"range\");\n    const endRange = range[nextIndex];\n\n    if (isNotNullish(endRange) && value > startRange && value < endRange) {\n      return [i, nextIndex];\n    }\n  }\n\n  // if no values was found, it means value is upper than last range value\n  return [maxIndex - 1, maxIndex];\n};\n\n/**\n * This function is similar to `Animated.interpolate` except this one can be used with numbers\n * Whereas `Animated.interpolate` works only with animated values and return a listener, not a single value\n */\nexport const interpolate = <T extends InterpolateTuple>({\n  inputRange: input,\n  outputRange: output,\n  clamp = true,\n}: InterpolateParams<T>): ((value: number) => number) => {\n  return (value: number): number => {\n    const [startIndex, endIndex] = getRangeIndexes(input, value);\n    const inputStart = getValue(input, startIndex, \"inputRange\");\n    const inputEnd = getValue(input, endIndex, \"inputRange\");\n    const lastInput = getValue(input, input.length - 1, \"inputRange\");\n    const outputStart = getValue(output, startIndex, \"outputRange\");\n    const outputEnd = getValue(output, endIndex, \"outputRange\");\n\n    const inputRange = inputEnd - inputStart;\n    const outputRange = outputEnd - outputStart;\n\n    const valueToConvert = clamp ? clampValue(input[0], lastInput)(value) : value;\n\n    const valueWithoutOffset = valueToConvert - inputStart;\n    const outputWithoutOffset = (outputRange * valueWithoutOffset) / inputRange;\n    const outputValue = outputWithoutOffset + outputStart;\n\n    return outputValue;\n  };\n};\n\ntype ElasticParams = {\n  elasticLength?: number; // the maximum value you can reach\n  elasticStrength?: number; // higher value, maximum value reached faster\n};\n\n/**\n * This function takes as input a number from 0 to Infinity and returns a number from 0 to elasticLength\n * With an exponential curve giving a feeling of elasticity\n * This kind of function can be used to:\n *  - recreate effect like scroll bounce on iOS\n *  - limit grab smoothly with touch interaction\n */\nexport const limitElastic =\n  ({ elasticLength = 100, elasticStrength = 0.008 }: ElasticParams) =>\n  (value: number): number =>\n    elasticLength * (1 - Math.exp(-elasticStrength * value));\n"],"names":["clampValue","min","max","value","limitElastic","elasticLength","elasticStrength"],"mappings":"AAmBO,MAAMA,EACX,CAACC,EAAaC,IACbC,GACC,KAAK,IAAI,KAAK,IAAIA,EAAOD,CAAG,EAAGD,CAAG,EAiEzBG,EACX,CAAC,CAAE,cAAAC,EAAgB,IAAK,gBAAAC,EAAkB,IAAM,IAC/CH,GACCE,GAAiB,EAAI,KAAK,IAAI,CAACC,EAAkBH,CAAK"}