{"version":3,"file":"TransitionView-2a5e1da3.js","sources":["../../../packages/lake/src/hooks/usePreviousValue.ts","../../../packages/lake/src/components/TransitionView.tsx"],"sourcesContent":["import { useEffect, useRef } from \"react\";\n\nexport const usePreviousValue = <T>(value: T): T => {\n  const previousRef = useRef(value);\n\n  useEffect(() => {\n    previousRef.current = value;\n  }, [value]);\n\n  return previousRef.current;\n};\n","import { ReactNode, useLayoutEffect, useReducer, useRef } from \"react\";\nimport { AnimationStyles, StyleProp, StyleSheet, View, ViewStyle } from \"react-native\";\nimport { usePreviousValue } from \"../hooks/usePreviousValue\";\nimport { isNotNullish, isNullish } from \"../utils/nullish\";\n\ntype Props = {\n  enter?: AnimationStyles;\n  leave?: AnimationStyles;\n  style?: StyleProp<ViewStyle>;\n  children: ReactNode | null;\n  onLeave?: () => void;\n};\n\nconst styles = StyleSheet.create({\n  base: {\n    animationFillMode: \"forwards\",\n  },\n});\n\nexport const TransitionView = ({ enter, leave, style, children, onLeave }: Props) => {\n  const viewRef = useRef<View>(null);\n  const childrenForLeaveAnimationRef = useRef<ReactNode | null>(null);\n  const [, forceUpdate] = useReducer(() => [], []);\n\n  const previousChildren = usePreviousValue(children);\n\n  if (isNullish(children) && isNotNullish(previousChildren) && isNotNullish(leave)) {\n    childrenForLeaveAnimationRef.current = previousChildren;\n  }\n\n  // Cleanup in case children reappear before the animation has performed\n  if (isNotNullish(children) && isNullish(previousChildren)) {\n    childrenForLeaveAnimationRef.current = null;\n  }\n\n  useLayoutEffect(() => {\n    if (isNullish(children) && isNotNullish(leave) && isNotNullish(viewRef.current)) {\n      const element = viewRef.current as unknown as Element;\n\n      const onAnimationEnd = () => {\n        childrenForLeaveAnimationRef.current = null;\n        forceUpdate();\n        onLeave?.();\n        element.removeEventListener(\"animationend\", onAnimationEnd);\n      };\n      element.addEventListener(\"animationend\", onAnimationEnd);\n\n      return () => element.removeEventListener(\"animationend\", onAnimationEnd);\n    }\n  }, [children, leave, onLeave]);\n\n  const hasChildrenToDisplay =\n    isNotNullish(children) || isNotNullish(childrenForLeaveAnimationRef.current);\n\n  return hasChildrenToDisplay ? (\n    <View\n      ref={viewRef}\n      style={[\n        styles.base,\n        style,\n        enter,\n        isNotNullish(childrenForLeaveAnimationRef.current) && leave,\n      ]}\n    >\n      {children ?? childrenForLeaveAnimationRef.current}\n    </View>\n  ) : null;\n};\n"],"names":["usePreviousValue","value","previousRef","useRef","useEffect","styles","StyleSheet","TransitionView","enter","leave","style","children","onLeave","viewRef","childrenForLeaveAnimationRef","forceUpdate","useReducer","previousChildren","isNullish","isNotNullish","useLayoutEffect","element","onAnimationEnd","jsx","View"],"mappings":"4GAEa,MAAAA,EAAuBC,GAAgB,CAC5C,MAAAC,EAAcC,SAAOF,CAAK,EAEhCG,OAAAA,EAAAA,UAAU,IAAM,CACdF,EAAY,QAAUD,CAAA,EACrB,CAACA,CAAK,CAAC,EAEHC,EAAY,OACrB,ECGAG,EAAAC,EAAA,OAAA,CAAiC,KAAA,CACzB,kBAAA,UACe,CAEvB,CAAA,EAEOC,EAAA,CAAA,CAAA,MAAAC,EAAA,MAAAC,EAAA,MAAAC,EAAA,SAAAC,EAAA,QAAAC,KAAA,CACL,MAAAC,EAAAV,SAAA,IAAA,EACAW,EAAAX,SAAA,IAAA,EACA,CAAA,CAAAY,CAAA,EAAAC,EAAAA,WAAA,IAAA,CAAA,EAAA,CAAA,CAAA,EAEAC,EAAAjB,EAAAW,CAAA,EAEA,OAAAO,EAAAP,CAAA,GAAAQ,EAAAF,CAAA,GAAAE,EAAAV,CAAA,IACEK,EAAA,QAAAG,GAIFE,EAAAR,CAAA,GAAAO,EAAAD,CAAA,IACEH,EAAA,QAAA,MAGFM,EAAAA,gBAAA,IAAA,CACE,GAAAF,EAAAP,CAAA,GAAAQ,EAAAV,CAAA,GAAAU,EAAAN,EAAA,OAAA,EAAA,CACE,MAAAQ,EAAAR,EAAA,QAEAS,EAAA,IAAA,CACER,EAAA,QAAA,KACAC,IACAH,GAAA,MAAAA,IACAS,EAAA,oBAAA,eAAAC,CAAA,CAA0D,EAE5D,OAAAD,EAAA,iBAAA,eAAAC,CAAA,EAEA,IAAAD,EAAA,oBAAA,eAAAC,CAAA,EACF,EAAA,CAAAX,EAAAF,EAAAG,CAAA,CAAA,EAGFO,EAAAR,CAAA,GAAAQ,EAAAL,EAAA,OAAA,EAGAS,EACEC,EAAC,CAAA,IAAAX,EACM,MAAA,CACER,EAAA,KACEK,EACPF,EACAW,EAAAL,EAAA,OAAA,GAAAL,CACsD,EACxD,SAAAE,GAAAG,EAAA,OAE0C,CAAA,EAAA,IAGhD"}