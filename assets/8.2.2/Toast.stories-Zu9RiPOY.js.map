{"version":3,"file":"Toast.stories-Zu9RiPOY.js","sources":["../../../node_modules/@0no-co/graphql.web/dist/graphql.web.mjs","../../../node_modules/@swan-io/graphql-client/dist/index.mjs","../../../node_modules/react-atomic-state/dist/index.module.js","../../../packages/lake/src/utils/timer.ts","../../../packages/lake/src/state/toasts.ts","../../../packages/lake/src/components/ToastStack.tsx"],"sourcesContent":["var e = {\n  NAME: \"Name\",\n  DOCUMENT: \"Document\",\n  OPERATION_DEFINITION: \"OperationDefinition\",\n  VARIABLE_DEFINITION: \"VariableDefinition\",\n  SELECTION_SET: \"SelectionSet\",\n  FIELD: \"Field\",\n  ARGUMENT: \"Argument\",\n  FRAGMENT_SPREAD: \"FragmentSpread\",\n  INLINE_FRAGMENT: \"InlineFragment\",\n  FRAGMENT_DEFINITION: \"FragmentDefinition\",\n  VARIABLE: \"Variable\",\n  INT: \"IntValue\",\n  FLOAT: \"FloatValue\",\n  STRING: \"StringValue\",\n  BOOLEAN: \"BooleanValue\",\n  NULL: \"NullValue\",\n  ENUM: \"EnumValue\",\n  LIST: \"ListValue\",\n  OBJECT: \"ObjectValue\",\n  OBJECT_FIELD: \"ObjectField\",\n  DIRECTIVE: \"Directive\",\n  NAMED_TYPE: \"NamedType\",\n  LIST_TYPE: \"ListType\",\n  NON_NULL_TYPE: \"NonNullType\"\n};\n\nvar r = {\n  QUERY: \"query\",\n  MUTATION: \"mutation\",\n  SUBSCRIPTION: \"subscription\"\n};\n\nclass GraphQLError extends Error {\n  constructor(e, r, i, n, a, t, l) {\n    super(e);\n    this.name = \"GraphQLError\";\n    this.message = e;\n    if (a) {\n      this.path = a;\n    }\n    if (r) {\n      this.nodes = Array.isArray(r) ? r : [ r ];\n    }\n    if (i) {\n      this.source = i;\n    }\n    if (n) {\n      this.positions = n;\n    }\n    if (t) {\n      this.originalError = t;\n    }\n    var o = l;\n    if (!o && t) {\n      var u = t.extensions;\n      if (u && \"object\" == typeof u) {\n        o = u;\n      }\n    }\n    this.extensions = o || {};\n  }\n  toJSON() {\n    return {\n      ...this,\n      message: this.message\n    };\n  }\n  toString() {\n    return this.message;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLError\";\n  }\n}\n\nvar i;\n\nvar n;\n\nfunction error(e) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${n} in ${e}`);\n}\n\nfunction advance(e) {\n  e.lastIndex = n;\n  if (e.test(i)) {\n    return i.slice(n, n = e.lastIndex);\n  }\n}\n\nvar a = / +(?=[^\\s])/y;\n\nfunction blockString(e) {\n  var r = e.split(\"\\n\");\n  var i = \"\";\n  var n = 0;\n  var t = 0;\n  var l = r.length - 1;\n  for (var o = 0; o < r.length; o++) {\n    a.lastIndex = 0;\n    if (a.test(r[o])) {\n      if (o && (!n || a.lastIndex < n)) {\n        n = a.lastIndex;\n      }\n      t = t || o;\n      l = o;\n    }\n  }\n  for (var u = t; u <= l; u++) {\n    if (u !== t) {\n      i += \"\\n\";\n    }\n    i += r[u].slice(n).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return i;\n}\n\nfunction ignored() {\n  for (var e = 0 | i.charCodeAt(n++); 9 === e || 10 === e || 13 === e || 32 === e || 35 === e || 44 === e || 65279 === e; e = 0 | i.charCodeAt(n++)) {\n    if (35 === e) {\n      while (10 !== (e = i.charCodeAt(n++)) && 13 !== e) {}\n    }\n  }\n  n--;\n}\n\nvar t = /[_A-Za-z]\\w*/y;\n\nvar l = new RegExp(\"(?:(null|true|false)|\\\\$(\" + t.source + ')|(-?\\\\d+)((?:\\\\.\\\\d+)?[eE][+-]?\\\\d+|\\\\.\\\\d+)?|(\"\"\"(?:\"\"\"|(?:[\\\\s\\\\S]*?[^\\\\\\\\])\"\"\"))|(\"(?:\"|[^\\\\r\\\\n]*?[^\\\\\\\\]\"))|(' + t.source + \"))\", \"y\");\n\nvar o = function(e) {\n  e[e.Const = 1] = \"Const\";\n  e[e.Var = 2] = \"Var\";\n  e[e.Int = 3] = \"Int\";\n  e[e.Float = 4] = \"Float\";\n  e[e.BlockString = 5] = \"BlockString\";\n  e[e.String = 6] = \"String\";\n  e[e.Enum = 7] = \"Enum\";\n  return e;\n}(o || {});\n\nvar u = /\\\\/g;\n\nfunction value(e) {\n  var r;\n  var a;\n  l.lastIndex = n;\n  if (91 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var d = [];\n    while (93 !== i.charCodeAt(n)) {\n      d.push(value(e));\n    }\n    n++;\n    ignored();\n    return {\n      kind: \"ListValue\",\n      values: d\n    };\n  } else if (123 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var v = [];\n    while (125 !== i.charCodeAt(n)) {\n      if (null == (r = advance(t))) {\n        throw error(\"ObjectField\");\n      }\n      ignored();\n      if (58 !== i.charCodeAt(n++)) {\n        throw error(\"ObjectField\");\n      }\n      ignored();\n      v.push({\n        kind: \"ObjectField\",\n        name: {\n          kind: \"Name\",\n          value: r\n        },\n        value: value(e)\n      });\n    }\n    n++;\n    ignored();\n    return {\n      kind: \"ObjectValue\",\n      fields: v\n    };\n  } else if (null != (a = l.exec(i))) {\n    n = l.lastIndex;\n    ignored();\n    if (null != (r = a[o.Const])) {\n      return \"null\" === r ? {\n        kind: \"NullValue\"\n      } : {\n        kind: \"BooleanValue\",\n        value: \"true\" === r\n      };\n    } else if (null != (r = a[o.Var])) {\n      if (e) {\n        throw error(\"Variable\");\n      } else {\n        return {\n          kind: \"Variable\",\n          name: {\n            kind: \"Name\",\n            value: r\n          }\n        };\n      }\n    } else if (null != (r = a[o.Int])) {\n      var s;\n      if (null != (s = a[o.Float])) {\n        return {\n          kind: \"FloatValue\",\n          value: r + s\n        };\n      } else {\n        return {\n          kind: \"IntValue\",\n          value: r\n        };\n      }\n    } else if (null != (r = a[o.BlockString])) {\n      return {\n        kind: \"StringValue\",\n        value: blockString(r.slice(3, -3)),\n        block: !0\n      };\n    } else if (null != (r = a[o.String])) {\n      return {\n        kind: \"StringValue\",\n        value: u.test(r) ? JSON.parse(r) : r.slice(1, -1),\n        block: !1\n      };\n    } else if (null != (r = a[o.Enum])) {\n      return {\n        kind: \"EnumValue\",\n        value: r\n      };\n    }\n  }\n  throw error(\"Value\");\n}\n\nfunction arguments_(e) {\n  if (40 === i.charCodeAt(n)) {\n    var r = [];\n    n++;\n    ignored();\n    var a;\n    do {\n      if (null == (a = advance(t))) {\n        throw error(\"Argument\");\n      }\n      ignored();\n      if (58 !== i.charCodeAt(n++)) {\n        throw error(\"Argument\");\n      }\n      ignored();\n      r.push({\n        kind: \"Argument\",\n        name: {\n          kind: \"Name\",\n          value: a\n        },\n        value: value(e)\n      });\n    } while (41 !== i.charCodeAt(n));\n    n++;\n    ignored();\n    return r;\n  }\n}\n\nfunction directives(e) {\n  if (64 === i.charCodeAt(n)) {\n    var r = [];\n    var a;\n    do {\n      n++;\n      if (null == (a = advance(t))) {\n        throw error(\"Directive\");\n      }\n      ignored();\n      r.push({\n        kind: \"Directive\",\n        name: {\n          kind: \"Name\",\n          value: a\n        },\n        arguments: arguments_(e)\n      });\n    } while (64 === i.charCodeAt(n));\n    return r;\n  }\n}\n\nfunction type() {\n  var e;\n  var r = 0;\n  while (91 === i.charCodeAt(n)) {\n    r++;\n    n++;\n    ignored();\n  }\n  if (null == (e = advance(t))) {\n    throw error(\"NamedType\");\n  }\n  ignored();\n  var a = {\n    kind: \"NamedType\",\n    name: {\n      kind: \"Name\",\n      value: e\n    }\n  };\n  do {\n    if (33 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      a = {\n        kind: \"NonNullType\",\n        type: a\n      };\n    }\n    if (r) {\n      if (93 !== i.charCodeAt(n++)) {\n        throw error(\"NamedType\");\n      }\n      ignored();\n      a = {\n        kind: \"ListType\",\n        type: a\n      };\n    }\n  } while (r--);\n  return a;\n}\n\nvar d = new RegExp(\"(?:(\\\\.{3})|(\" + t.source + \"))\", \"y\");\n\nvar v = function(e) {\n  e[e.Spread = 1] = \"Spread\";\n  e[e.Name = 2] = \"Name\";\n  return e;\n}(v || {});\n\nfunction selectionSet() {\n  var e = [];\n  var r;\n  var a;\n  do {\n    d.lastIndex = n;\n    if (null != (a = d.exec(i))) {\n      n = d.lastIndex;\n      if (null != a[v.Spread]) {\n        ignored();\n        var l = advance(t);\n        if (null != l && \"on\" !== l) {\n          ignored();\n          e.push({\n            kind: \"FragmentSpread\",\n            name: {\n              kind: \"Name\",\n              value: l\n            },\n            directives: directives(!1)\n          });\n        } else {\n          ignored();\n          if (\"on\" === l) {\n            if (null == (l = advance(t))) {\n              throw error(\"NamedType\");\n            }\n            ignored();\n          }\n          var o = directives(!1);\n          if (123 !== i.charCodeAt(n++)) {\n            throw error(\"InlineFragment\");\n          }\n          ignored();\n          e.push({\n            kind: \"InlineFragment\",\n            typeCondition: l ? {\n              kind: \"NamedType\",\n              name: {\n                kind: \"Name\",\n                value: l\n              }\n            } : void 0,\n            directives: o,\n            selectionSet: selectionSet()\n          });\n        }\n      } else if (null != (r = a[v.Name])) {\n        var u = void 0;\n        ignored();\n        if (58 === i.charCodeAt(n)) {\n          n++;\n          ignored();\n          u = r;\n          if (null == (r = advance(t))) {\n            throw error(\"Field\");\n          }\n          ignored();\n        }\n        var s = arguments_(!1);\n        ignored();\n        var c = directives(!1);\n        var f = void 0;\n        if (123 === i.charCodeAt(n)) {\n          n++;\n          ignored();\n          f = selectionSet();\n        }\n        e.push({\n          kind: \"Field\",\n          alias: u ? {\n            kind: \"Name\",\n            value: u\n          } : void 0,\n          name: {\n            kind: \"Name\",\n            value: r\n          },\n          arguments: s,\n          directives: c,\n          selectionSet: f\n        });\n      }\n    } else {\n      throw error(\"SelectionSet\");\n    }\n  } while (125 !== i.charCodeAt(n));\n  n++;\n  ignored();\n  return {\n    kind: \"SelectionSet\",\n    selections: e\n  };\n}\n\nfunction fragmentDefinition() {\n  var e;\n  var r;\n  if (null == (e = advance(t))) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  if (\"on\" !== advance(t)) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  if (null == (r = advance(t))) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  var a = directives(!1);\n  if (123 !== i.charCodeAt(n++)) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  return {\n    kind: \"FragmentDefinition\",\n    name: {\n      kind: \"Name\",\n      value: e\n    },\n    typeCondition: {\n      kind: \"NamedType\",\n      name: {\n        kind: \"Name\",\n        value: r\n      }\n    },\n    directives: a,\n    selectionSet: selectionSet()\n  };\n}\n\nvar s = /(?:query|mutation|subscription|fragment)/y;\n\nfunction operationDefinition(e) {\n  var r;\n  var a;\n  var l;\n  if (e) {\n    ignored();\n    r = advance(t);\n    a = function variableDefinitions() {\n      ignored();\n      if (40 === i.charCodeAt(n)) {\n        var e = [];\n        n++;\n        ignored();\n        var r;\n        do {\n          if (36 !== i.charCodeAt(n++)) {\n            throw error(\"Variable\");\n          }\n          if (null == (r = advance(t))) {\n            throw error(\"Variable\");\n          }\n          ignored();\n          if (58 !== i.charCodeAt(n++)) {\n            throw error(\"VariableDefinition\");\n          }\n          ignored();\n          var a = type();\n          var l = void 0;\n          if (61 === i.charCodeAt(n)) {\n            n++;\n            ignored();\n            l = value(!0);\n          }\n          ignored();\n          e.push({\n            kind: \"VariableDefinition\",\n            variable: {\n              kind: \"Variable\",\n              name: {\n                kind: \"Name\",\n                value: r\n              }\n            },\n            type: a,\n            defaultValue: l,\n            directives: directives(!0)\n          });\n        } while (41 !== i.charCodeAt(n));\n        n++;\n        ignored();\n        return e;\n      }\n    }();\n    l = directives(!1);\n  }\n  if (123 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    return {\n      kind: \"OperationDefinition\",\n      operation: e || \"query\",\n      name: r ? {\n        kind: \"Name\",\n        value: r\n      } : void 0,\n      variableDefinitions: a,\n      directives: l,\n      selectionSet: selectionSet()\n    };\n  }\n}\n\nfunction parse(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return function document() {\n    var e;\n    var r;\n    ignored();\n    var a = [];\n    do {\n      if (\"fragment\" === (e = advance(s))) {\n        ignored();\n        a.push(fragmentDefinition());\n      } else if (null != (r = operationDefinition(e))) {\n        a.push(r);\n      } else {\n        throw error(\"Document\");\n      }\n    } while (n < i.length);\n    return {\n      kind: \"Document\",\n      definitions: a\n    };\n  }();\n}\n\nfunction parseValue(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  ignored();\n  return value(!1);\n}\n\nfunction parseType(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return type();\n}\n\nvar c = {};\n\nfunction visit(e, r) {\n  var i = [];\n  var n = [];\n  try {\n    var a = function traverse(e, a, t) {\n      var l = !1;\n      var o = r[e.kind] && r[e.kind].enter || r[e.kind] || r.enter;\n      var u = o && o.call(r, e, a, t, n, i);\n      if (!1 === u) {\n        return e;\n      } else if (null === u) {\n        return null;\n      } else if (u === c) {\n        throw c;\n      } else if (u && \"string\" == typeof u.kind) {\n        l = u !== e;\n        e = u;\n      }\n      if (t) {\n        i.push(t);\n      }\n      var d;\n      var v = {\n        ...e\n      };\n      for (var s in e) {\n        n.push(s);\n        var f = e[s];\n        if (Array.isArray(f)) {\n          var m = [];\n          for (var g = 0; g < f.length; g++) {\n            if (null != f[g] && \"string\" == typeof f[g].kind) {\n              i.push(e);\n              n.push(g);\n              d = traverse(f[g], g, f);\n              n.pop();\n              i.pop();\n              if (null == d) {\n                l = !0;\n              } else {\n                l = l || d !== f[g];\n                m.push(d);\n              }\n            }\n          }\n          f = m;\n        } else if (null != f && \"string\" == typeof f.kind) {\n          if (void 0 !== (d = traverse(f, s, e))) {\n            l = l || f !== d;\n            f = d;\n          }\n        }\n        n.pop();\n        if (l) {\n          v[s] = f;\n        }\n      }\n      if (t) {\n        i.pop();\n      }\n      var p = r[e.kind] && r[e.kind].leave || r.leave;\n      var h = p && p.call(r, e, a, t, n, i);\n      if (h === c) {\n        throw c;\n      } else if (void 0 !== h) {\n        return h;\n      } else if (void 0 !== u) {\n        return l ? v : u;\n      } else {\n        return l ? v : e;\n      }\n    }(e);\n    return void 0 !== a && !1 !== a ? a : e;\n  } catch (r) {\n    if (r !== c) {\n      throw r;\n    }\n    return e;\n  }\n}\n\nfunction mapJoin(e, r, i) {\n  var n = \"\";\n  for (var a = 0; a < e.length; a++) {\n    if (a) {\n      n += r;\n    }\n    n += i(e[a]);\n  }\n  return n;\n}\n\nfunction printString(e) {\n  return JSON.stringify(e);\n}\n\nfunction printBlockString(e) {\n  return '\"\"\"\\n' + e.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nvar f = \"\\n\";\n\nvar m = {\n  OperationDefinition(e) {\n    var r = e.operation;\n    if (e.name) {\n      r += \" \" + e.name.value;\n    }\n    if (e.variableDefinitions && e.variableDefinitions.length) {\n      if (!e.name) {\n        r += \" \";\n      }\n      r += \"(\" + mapJoin(e.variableDefinitions, \", \", m.VariableDefinition) + \")\";\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", m.Directive);\n    }\n    return \"query\" !== r ? r + \" \" + m.SelectionSet(e.selectionSet) : m.SelectionSet(e.selectionSet);\n  },\n  VariableDefinition(e) {\n    var r = m.Variable(e.variable) + \": \" + _print(e.type);\n    if (e.defaultValue) {\n      r += \" = \" + _print(e.defaultValue);\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", m.Directive);\n    }\n    return r;\n  },\n  Field(e) {\n    var r = e.alias ? e.alias.value + \": \" + e.name.value : e.name.value;\n    if (e.arguments && e.arguments.length) {\n      var i = mapJoin(e.arguments, \", \", m.Argument);\n      if (r.length + i.length + 2 > 80) {\n        r += \"(\" + (f += \"  \") + mapJoin(e.arguments, f, m.Argument) + (f = f.slice(0, -2)) + \")\";\n      } else {\n        r += \"(\" + i + \")\";\n      }\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", m.Directive);\n    }\n    if (e.selectionSet) {\n      r += \" \" + m.SelectionSet(e.selectionSet);\n    }\n    return r;\n  },\n  StringValue(e) {\n    if (e.block) {\n      return printBlockString(e.value).replace(/\\n/g, f);\n    } else {\n      return printString(e.value);\n    }\n  },\n  BooleanValue: e => \"\" + e.value,\n  NullValue: e => \"null\",\n  IntValue: e => e.value,\n  FloatValue: e => e.value,\n  EnumValue: e => e.value,\n  Name: e => e.value,\n  Variable: e => \"$\" + e.name.value,\n  ListValue: e => \"[\" + mapJoin(e.values, \", \", _print) + \"]\",\n  ObjectValue: e => \"{\" + mapJoin(e.fields, \", \", m.ObjectField) + \"}\",\n  ObjectField: e => e.name.value + \": \" + _print(e.value),\n  Document(e) {\n    if (!e.definitions || !e.definitions.length) {\n      return \"\";\n    }\n    return mapJoin(e.definitions, \"\\n\\n\", _print);\n  },\n  SelectionSet: e => \"{\" + (f += \"  \") + mapJoin(e.selections, f, _print) + (f = f.slice(0, -2)) + \"}\",\n  Argument: e => e.name.value + \": \" + _print(e.value),\n  FragmentSpread(e) {\n    var r = \"...\" + e.name.value;\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", m.Directive);\n    }\n    return r;\n  },\n  InlineFragment(e) {\n    var r = \"...\";\n    if (e.typeCondition) {\n      r += \" on \" + e.typeCondition.name.value;\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", m.Directive);\n    }\n    return r += \" \" + m.SelectionSet(e.selectionSet);\n  },\n  FragmentDefinition(e) {\n    var r = \"fragment \" + e.name.value;\n    r += \" on \" + e.typeCondition.name.value;\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", m.Directive);\n    }\n    return r + \" \" + m.SelectionSet(e.selectionSet);\n  },\n  Directive(e) {\n    var r = \"@\" + e.name.value;\n    if (e.arguments && e.arguments.length) {\n      r += \"(\" + mapJoin(e.arguments, \", \", m.Argument) + \")\";\n    }\n    return r;\n  },\n  NamedType: e => e.name.value,\n  ListType: e => \"[\" + _print(e.type) + \"]\",\n  NonNullType: e => _print(e.type) + \"!\"\n};\n\nvar _print = e => m[e.kind](e);\n\nfunction print(e) {\n  f = \"\\n\";\n  return m[e.kind] ? m[e.kind](e) : \"\";\n}\n\nfunction valueFromASTUntyped(e, r) {\n  switch (e.kind) {\n   case \"NullValue\":\n    return null;\n\n   case \"IntValue\":\n    return parseInt(e.value, 10);\n\n   case \"FloatValue\":\n    return parseFloat(e.value);\n\n   case \"StringValue\":\n   case \"EnumValue\":\n   case \"BooleanValue\":\n    return e.value;\n\n   case \"ListValue\":\n    var i = [];\n    for (var n of e.values) {\n      i.push(valueFromASTUntyped(n, r));\n    }\n    return i;\n\n   case \"ObjectValue\":\n    var a = Object.create(null);\n    for (var t of e.fields) {\n      a[t.name.value] = valueFromASTUntyped(t.value, r);\n    }\n    return a;\n\n   case \"Variable\":\n    return r && r[e.name.value];\n  }\n}\n\nfunction valueFromTypeNode(e, r, i) {\n  if (\"Variable\" === e.kind) {\n    return i ? valueFromTypeNode(i[e.name.value], r, i) : void 0;\n  } else if (\"NonNullType\" === r.kind) {\n    return \"NullValue\" !== e.kind ? valueFromTypeNode(e, r, i) : void 0;\n  } else if (\"NullValue\" === e.kind) {\n    return null;\n  } else if (\"ListType\" === r.kind) {\n    if (\"ListValue\" === e.kind) {\n      var n = [];\n      for (var a of e.values) {\n        var t = valueFromTypeNode(a, r.type, i);\n        if (void 0 === t) {\n          return;\n        } else {\n          n.push(t);\n        }\n      }\n      return n;\n    }\n  } else if (\"NamedType\" === r.kind) {\n    switch (r.name.value) {\n     case \"Int\":\n     case \"Float\":\n     case \"String\":\n     case \"Bool\":\n      return r.name.value + \"Value\" === e.kind ? valueFromASTUntyped(e, i) : void 0;\n\n     default:\n      return valueFromASTUntyped(e, i);\n    }\n  }\n}\n\nexport { c as BREAK, GraphQLError, e as Kind, r as OperationTypeNode, parse, parseType, parseValue, print, printBlockString, printString, valueFromASTUntyped, valueFromTypeNode, visit };\n//# sourceMappingURL=graphql.web.mjs.map\n","import { Option, Future, Result, AsyncData, Deferred, Array as Array$1 } from '@swan-io/boxed';\nimport { Request, badStatusToError, emptyToError } from '@swan-io/request';\nimport { match, P } from 'ts-pattern';\nimport { Kind, GraphQLError, visit, OperationTypeNode } from '@0no-co/graphql.web';\nimport { createContext, useContext, useState, useRef, useCallback, useSyncExternalStore, useMemo, useEffect } from 'react';\n\n// src/client.ts\n\n// src/utils.ts\nvar DEEP_MERGE_DELETE = Symbol.for(\"DEEP_MERGE_DELETE\");\nvar REQUESTED_KEYS = Symbol.for(\"__requestedKeys\");\nvar deepMerge = (target, source) => {\n  if (target instanceof Set && source instanceof Set) {\n    return /* @__PURE__ */ new Set([...target, ...source]);\n  }\n  const next = Array.isArray(target) ? Array(target.length) : Array.isArray(source) ? Array(source.length) : {};\n  Object.getOwnPropertyNames(target).forEach((name) => {\n    if (source[name] !== DEEP_MERGE_DELETE) {\n      next[name] = target[name];\n    }\n  });\n  Object.getOwnPropertySymbols(target).forEach((name) => {\n    if (source[name] !== DEEP_MERGE_DELETE) {\n      next[name] = target[name];\n    }\n  });\n  Object.getOwnPropertyNames(source).forEach((name) => {\n    if (source[name] !== DEEP_MERGE_DELETE) {\n      if (isRecord(next[name]) && isRecord(source[name])) {\n        next[name] = deepMerge(next[name], source[name]);\n      } else {\n        next[name] = source[name];\n      }\n    }\n  });\n  Object.getOwnPropertySymbols(source).forEach((name) => {\n    if (source[name] !== DEEP_MERGE_DELETE) {\n      if (isRecord(next[name]) && isRecord(source[name])) {\n        next[name] = deepMerge(next[name], source[name]);\n      } else {\n        next[name] = source[name];\n      }\n    }\n  });\n  return next;\n};\nvar containsAll = (a, b) => {\n  const keys = [...b.values()];\n  return keys.every((key) => a.has(key));\n};\nvar isRecord = (value) => {\n  return value != null && typeof value === \"object\";\n};\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar deepEqual = (a, b) => {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  if (typeof a !== \"object\" || a === null || typeof b !== \"object\" || b === null) {\n    return false;\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  for (const key of aKeys) {\n    if (!hasOwnProperty.call(b, key) || !deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n};\nvar serializeVariables = (variables) => {\n  return JSON.stringify(variables);\n};\n\n// src/cache/cache.ts\nvar getCacheKeyFromJson = (json) => {\n  return match(json).with(\n    { __typename: P.select(P.union(\"Query\", \"Mutation\", \"Subscription\")) },\n    (name) => Option.Some(Symbol.for(name))\n  ).with(\n    { __typename: P.select(\"name\", P.string), id: P.select(\"id\", P.string) },\n    ({ name, id }) => Option.Some(Symbol.for(`${name}<${id}>`))\n  ).otherwise(() => Option.None());\n};\nvar getCacheKeyFromOperationNode = (operationNode) => {\n  return match(operationNode.operation).with(OperationTypeNode.QUERY, () => Option.Some(Symbol.for(\"Query\"))).with(\n    OperationTypeNode.SUBSCRIPTION,\n    () => Option.Some(Symbol.for(\"Subscription\"))\n  ).otherwise(() => Option.None());\n};\nvar ClientCache = class {\n  constructor(schemaConfig) {\n    this.cache = /* @__PURE__ */ new Map();\n    this.operationCache = /* @__PURE__ */ new Map();\n    this.schemaConfig = Object.fromEntries(\n      Object.entries(schemaConfig.interfaceToTypes).map(([key, value]) => [\n        key,\n        new Set(value)\n      ])\n    );\n  }\n  isTypeCompatible(typename, typeCondition) {\n    if (typename === typeCondition) {\n      return true;\n    }\n    const compatibleTypes = this.schemaConfig[typeCondition];\n    if (compatibleTypes == void 0) {\n      return false;\n    }\n    return compatibleTypes.has(typename);\n  }\n  dump() {\n    return this.cache;\n  }\n  getOperationFromCache(documentNode, variables) {\n    const serializedVariables = serializeVariables(variables);\n    return Option.fromNullable(this.operationCache.get(documentNode)).flatMap((cache) => Option.fromNullable(cache.get(serializedVariables))).flatMap((value) => value);\n  }\n  setOperationInCache(documentNode, variables, data) {\n    const serializedVariables = serializeVariables(variables);\n    const documentCache = Option.fromNullable(\n      this.operationCache.get(documentNode)\n    ).getOr(/* @__PURE__ */ new Map());\n    documentCache.set(serializedVariables, Option.Some(data));\n    this.operationCache.set(documentNode, documentCache);\n  }\n  getFromCache(cacheKey, requestedKeys) {\n    return this.get(cacheKey).flatMap((entry) => {\n      if (isRecord(entry)) {\n        if (containsAll(entry[REQUESTED_KEYS], requestedKeys)) {\n          return Option.Some(entry);\n        } else {\n          return Option.None();\n        }\n      } else {\n        return Option.Some(entry);\n      }\n    });\n  }\n  getFromCacheWithoutKey(cacheKey) {\n    return this.get(cacheKey).flatMap((entry) => {\n      return Option.Some(entry);\n    });\n  }\n  get(cacheKey) {\n    if (this.cache.has(cacheKey)) {\n      return Option.Some(this.cache.get(cacheKey));\n    } else {\n      return Option.None();\n    }\n  }\n  getOrDefault(cacheKey) {\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    } else {\n      return {};\n    }\n  }\n  set(cacheKey, entry) {\n    this.cache.set(cacheKey, entry);\n  }\n  cacheIfEligible(value, requestedKeys) {\n    const cacheKeyOption = getCacheKeyFromJson(value);\n    if (cacheKeyOption.isSome()) {\n      const cacheKey = cacheKeyOption.get();\n      const existingEntry = this.getOrDefault(cacheKey);\n      this.set(\n        cacheKey,\n        deepMerge(\n          existingEntry,\n          isRecord(value) ? { ...value, [REQUESTED_KEYS]: requestedKeys } : value\n        )\n      );\n      return cacheKey;\n    } else {\n      return value;\n    }\n  }\n  updateFieldInClosestCachedAncestor({\n    originalFieldName,\n    fieldNameWithArguments,\n    value,\n    path,\n    ancestors,\n    variables,\n    rootTypename,\n    selectedKeys\n  }) {\n    const ancestorsCopy = ancestors.concat();\n    const pathCopy = path.concat();\n    const writePath = [];\n    let ancestor;\n    while (ancestor = ancestorsCopy.pop()) {\n      const maybeCacheKey = getCacheKeyFromJson(\n        ancestorsCopy.length === 0 ? { ...ancestor, __typename: rootTypename } : ancestor\n      );\n      if (maybeCacheKey.isSome()) {\n        const cacheKey = maybeCacheKey.get();\n        const existingEntry = this.getOrDefault(cacheKey);\n        if (isRecord(value) && !Array$1.isArray(value)) {\n          if (typeof value.__typename === \"string\" && value.__typename.endsWith(\"Connection\")) {\n            value.__connectionCacheKey = cacheKey.description;\n            value.__connectionCachePath = [\n              [...writePath, fieldNameWithArguments].map(\n                (item) => typeof item === \"symbol\" ? { symbol: item.description } : item\n              )\n            ];\n            value.__connectionArguments = variables;\n          }\n          value[REQUESTED_KEYS] = selectedKeys;\n        }\n        const deepUpdate = writePath.reduce(\n          (acc, key) => {\n            return {\n              [key]: acc\n            };\n          },\n          // remote original field\n          {\n            [originalFieldName]: DEEP_MERGE_DELETE,\n            [fieldNameWithArguments]: value\n          }\n        );\n        this.set(cacheKey, deepMerge(existingEntry, deepUpdate));\n        break;\n      }\n      writePath.push(pathCopy.pop());\n    }\n  }\n  unsafe__update(cacheKey, path, updater) {\n    this.get(cacheKey).map((cachedAncestor) => {\n      const value = path.reduce(\n        (acc, key) => acc.flatMap(\n          (acc2) => Option.fromNullable(isRecord(acc2) ? acc2[key] : null)\n        ),\n        Option.fromNullable(cachedAncestor)\n      );\n      value.map((item) => {\n        const deepUpdate = path.reduce(\n          (acc, key) => {\n            return {\n              [key]: acc\n            };\n          },\n          updater(item)\n        );\n        this.set(cacheKey, deepMerge(cachedAncestor, deepUpdate));\n      });\n    });\n  }\n  updateConnection(connection, config) {\n    match(connection).with(\n      {\n        __connectionCacheKey: P.string,\n        __connectionCachePath: P.array(\n          P.array(P.union({ symbol: P.string }, P.string))\n        )\n      },\n      ({ __connectionCacheKey, __connectionCachePath }) => {\n        const cacheKey = Symbol.for(__connectionCacheKey);\n        const cachePath = __connectionCachePath.map(\n          (path) => path.map(\n            (item) => typeof item === \"string\" ? item : Symbol.for(item.symbol)\n          )\n        );\n        const typenameSymbol = Symbol.for(\"__typename\");\n        const edgesSymbol = Symbol.for(\"edges\");\n        const nodeSymbol = Symbol.for(\"node\");\n        match(config).with({ prepend: P.select(P.nonNullable) }, (edges) => {\n          const firstPath = cachePath[0];\n          if (firstPath != null) {\n            this.unsafe__update(cacheKey, firstPath, (value) => {\n              if (!isRecord(value) || !Array$1.isArray(value[edgesSymbol])) {\n                return value;\n              }\n              return {\n                ...value,\n                [edgesSymbol]: [\n                  ...Array$1.filterMap(\n                    edges,\n                    ({ node, __typename }) => getCacheKeyFromJson(node).flatMap(\n                      (key) => (\n                        // we can omit the requested fields here because the Connection<A> contrains the fields\n                        this.getFromCacheWithoutKey(key).map(() => ({\n                          [typenameSymbol]: __typename,\n                          [nodeSymbol]: key\n                        }))\n                      )\n                    )\n                  ),\n                  ...value[edgesSymbol]\n                ]\n              };\n            });\n          }\n        }).with({ append: P.select(P.nonNullable) }, (edges) => {\n          const lastPath = cachePath[cachePath.length - 1];\n          if (lastPath != null) {\n            this.unsafe__update(cacheKey, lastPath, (value) => {\n              if (!isRecord(value) || !Array$1.isArray(value[edgesSymbol])) {\n                return value;\n              }\n              return {\n                ...value,\n                [edgesSymbol]: [\n                  ...value[edgesSymbol],\n                  ...Array$1.filterMap(\n                    edges,\n                    ({ node, __typename }) => getCacheKeyFromJson(node).flatMap(\n                      (key) => (\n                        // we can omit the requested fields here because the Connection<A> contrains the fields\n                        this.getFromCacheWithoutKey(key).map(() => ({\n                          [typenameSymbol]: __typename,\n                          [nodeSymbol]: key\n                        }))\n                      )\n                    )\n                  )\n                ]\n              };\n            });\n          }\n        }).with({ remove: P.select(P.array()) }, (nodeIds) => {\n          cachePath.forEach((path) => {\n            this.unsafe__update(cacheKey, path, (value) => {\n              return isRecord(value) && Array$1.isArray(value[edgesSymbol]) ? {\n                ...value,\n                [edgesSymbol]: value[edgesSymbol].filter((edge) => {\n                  const node = edge[nodeSymbol];\n                  return !nodeIds.some((nodeId) => {\n                    var _a;\n                    return (_a = node.description) == null ? void 0 : _a.includes(`<${nodeId}>`);\n                  });\n                })\n              } : value;\n            });\n          });\n        }).exhaustive();\n      }\n    ).otherwise(() => {\n    });\n  }\n};\nvar getSelectedKeys = (fieldNode, variables) => {\n  const selectedKeys = /* @__PURE__ */ new Set();\n  const traverse = (selections) => {\n    selections.selections.forEach((selection) => {\n      if (selection.kind === Kind.FIELD) {\n        const fieldNameWithArguments = getFieldNameWithArguments(\n          selection,\n          variables\n        );\n        selectedKeys.add(fieldNameWithArguments);\n      } else if (selection.kind === Kind.INLINE_FRAGMENT) {\n        traverse(selection.selectionSet);\n      }\n    });\n  };\n  if (fieldNode.selectionSet) {\n    traverse(fieldNode.selectionSet);\n  }\n  return selectedKeys;\n};\nvar getFieldNameWithArguments = (fieldNode, variables) => {\n  const fieldName = getFieldName(fieldNode);\n  const args = extractArguments(fieldNode, variables);\n  if (Object.keys(args).length === 0) {\n    return Symbol.for(fieldName);\n  }\n  return Symbol.for(`${fieldName}(${JSON.stringify(args)})`);\n};\nvar extractArguments = (fieldNode, variables) => {\n  var _a;\n  const args = (_a = fieldNode.arguments) != null ? _a : [];\n  return Object.fromEntries(\n    args.map(({ name: { value: name }, value }) => [\n      name,\n      extractValue(value, variables)\n    ])\n  );\n};\nvar extractValue = (valueNode, variables) => {\n  return match(valueNode).with({ kind: Kind.NULL }, () => null).with(\n    {\n      kind: P.union(\n        Kind.INT,\n        Kind.FLOAT,\n        Kind.STRING,\n        Kind.BOOLEAN,\n        Kind.ENUM\n      )\n    },\n    ({ value }) => value\n  ).with(\n    { kind: Kind.LIST },\n    ({ values }) => values.map((value) => extractValue(value, variables))\n  ).with(\n    { kind: Kind.OBJECT },\n    ({ fields }) => Object.fromEntries(\n      fields.map(({ name: { value: name }, value }) => [name, value])\n    )\n  ).with(\n    { kind: Kind.VARIABLE },\n    ({ name: { value: name } }) => variables[name]\n  ).exhaustive();\n};\nvar getFieldName = (fieldNode) => {\n  return fieldNode.alias ? fieldNode.alias.value : fieldNode.name.value;\n};\nvar inlineFragments = (documentNode) => {\n  const fragmentMap = {};\n  visit(documentNode, {\n    [Kind.FRAGMENT_DEFINITION](node) {\n      fragmentMap[node.name.value] = node;\n    }\n  });\n  const inline = (node) => {\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n      const fragmentNode = fragmentMap[fragmentName];\n      if (!fragmentNode) {\n        throw new Error(`Fragment \"${fragmentName}\" is not defined.`);\n      }\n      const nextNode = {\n        kind: Kind.INLINE_FRAGMENT,\n        typeCondition: fragmentNode.typeCondition,\n        selectionSet: fragmentNode.selectionSet\n      };\n      return nextNode;\n    }\n    if (node.kind === Kind.SELECTION_SET) {\n      return {\n        ...node,\n        selections: node.selections.map(\n          (selection) => inline(selection)\n        )\n      };\n    }\n    if (\"selectionSet\" in node && node.selectionSet != null) {\n      return {\n        ...node,\n        selectionSet: inline(node.selectionSet)\n      };\n    }\n    return node;\n  };\n  return visit(documentNode, {\n    [Kind.FRAGMENT_DEFINITION]: () => null,\n    enter: inline\n  });\n};\nvar TYPENAME_NODE = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\"\n  }\n};\nvar addTypenames = (documentNode) => {\n  return visit(documentNode, {\n    [Kind.SELECTION_SET]: (selectionSet) => {\n      if (selectionSet.selections.find(\n        (selection) => selection.kind === Kind.FIELD && selection.name.value === \"__typename\"\n      )) {\n        return selectionSet;\n      } else {\n        return {\n          ...selectionSet,\n          selections: [TYPENAME_NODE, ...selectionSet.selections]\n        };\n      }\n    }\n  });\n};\nvar getExecutableOperationName = (document) => {\n  return Array$1.findMap(document.definitions, (definition) => {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      return Option.fromNullable(definition.name).map((name) => name.value);\n    } else {\n      return Option.None();\n    }\n  });\n};\nvar getIdFieldNode = (selection) => {\n  return match(selection).with(\n    { kind: Kind.FIELD },\n    (fieldNode) => fieldNode.name.value === \"id\" ? Option.Some(fieldNode) : Option.None()\n  ).with({ kind: Kind.INLINE_FRAGMENT }, (inlineFragmentNode) => {\n    return Array$1.findMap(\n      inlineFragmentNode.selectionSet.selections,\n      getIdFieldNode\n    );\n  }).otherwise(() => Option.None());\n};\nvar addIdIfPreviousSelected = (oldSelectionSet, newSelectionSet) => {\n  const idSelection = Array$1.findMap(oldSelectionSet.selections, getIdFieldNode);\n  const idSelectionInNew = Array$1.findMap(\n    newSelectionSet.selections,\n    getIdFieldNode\n  );\n  if (idSelectionInNew.isSome()) {\n    return newSelectionSet;\n  }\n  return idSelection.map((selection) => ({\n    ...newSelectionSet,\n    selections: [\n      selection,\n      ...newSelectionSet.selections\n    ]\n  })).getOr(newSelectionSet);\n};\nvar isExcluded = (fieldNode, variables) => {\n  if (!Array$1.isArray(fieldNode.directives)) {\n    return false;\n  }\n  return fieldNode.directives.some(\n    (directive) => directive.name.value === \"include\" && directive.arguments != null && directive.arguments.some((arg) => {\n      return arg.name.value === \"if\" && extractValue(arg.value, variables) === false;\n    })\n  );\n};\n\n// src/cache/read.ts\nvar getFromCacheOrReturnValue = (cache, valueOrKey, selectedKeys) => {\n  if (typeof valueOrKey === \"symbol\") {\n    return cache.getFromCache(valueOrKey, selectedKeys).flatMap(Option.fromNullable);\n  }\n  if (isRecord(valueOrKey) && REQUESTED_KEYS in valueOrKey && valueOrKey[REQUESTED_KEYS] instanceof Set) {\n    if (containsAll(valueOrKey[REQUESTED_KEYS], selectedKeys)) {\n      return Option.Some(valueOrKey);\n    } else {\n      return Option.None();\n    }\n  }\n  return Option.Some(valueOrKey);\n};\nvar getFromCacheOrReturnValueWithoutKeyFilter = (cache, valueOrKey) => {\n  return typeof valueOrKey === \"symbol\" ? cache.getFromCacheWithoutKey(valueOrKey).flatMap(Option.fromNullable) : Option.Some(valueOrKey);\n};\nvar STABILITY_CACHE = /* @__PURE__ */ new WeakMap();\nvar EXCLUDED = Symbol.for(\"EXCLUDED\");\nvar readOperationFromCache = (cache, document, variables) => {\n  const traverse = (selections, data) => {\n    return selections.selections.reduce((data2, selection) => {\n      return data2.flatMap((data3) => {\n        var _a;\n        if (selection.kind === Kind.FIELD) {\n          const fieldNode = selection;\n          const originalFieldName = getFieldName(fieldNode);\n          const fieldNameWithArguments = getFieldNameWithArguments(\n            fieldNode,\n            variables\n          );\n          if (data3 == void 0) {\n            return Option.None();\n          }\n          const cacheHasKey = hasOwnProperty.call(data3, originalFieldName) || hasOwnProperty.call(data3, fieldNameWithArguments);\n          if (!cacheHasKey) {\n            if (isExcluded(fieldNode, variables)) {\n              return Option.Some({\n                ...data3,\n                [originalFieldName]: EXCLUDED\n              });\n            } else {\n              return Option.None();\n            }\n          }\n          const valueOrKeyFromCache = (\n            // @ts-expect-error `data` is indexable at this point\n            originalFieldName in data3 ? (\n              // @ts-expect-error `data` is indexable at this point\n              data3[originalFieldName]\n            ) : (\n              // @ts-expect-error `data` is indexable at this point\n              data3[fieldNameWithArguments]\n            )\n          );\n          if (valueOrKeyFromCache == void 0) {\n            return Option.Some({\n              ...data3,\n              [originalFieldName]: valueOrKeyFromCache\n            });\n          }\n          if (Array$1.isArray(valueOrKeyFromCache)) {\n            const selectedKeys = getSelectedKeys(fieldNode, variables);\n            return Option.all(\n              valueOrKeyFromCache.map((valueOrKey) => {\n                const value = getFromCacheOrReturnValue(\n                  cache,\n                  valueOrKey,\n                  selectedKeys\n                );\n                return value.flatMap((value2) => {\n                  if (isRecord(value2) && fieldNode.selectionSet != void 0) {\n                    return traverse(fieldNode.selectionSet, value2);\n                  } else {\n                    return Option.Some(value2);\n                  }\n                });\n              })\n            ).map((result) => ({\n              ...data3,\n              [originalFieldName]: result\n            }));\n          } else {\n            const selectedKeys = getSelectedKeys(fieldNode, variables);\n            const value = getFromCacheOrReturnValue(\n              cache,\n              valueOrKeyFromCache,\n              selectedKeys\n            );\n            return value.flatMap((value2) => {\n              if (isRecord(value2) && fieldNode.selectionSet != void 0) {\n                return traverse(\n                  fieldNode.selectionSet,\n                  value2\n                ).map((result) => ({\n                  ...data3,\n                  [originalFieldName]: result\n                }));\n              } else {\n                return Option.Some({ ...data3, [originalFieldName]: value2 });\n              }\n            });\n          }\n        }\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\n          const inlineFragmentNode = selection;\n          const typeCondition = (_a = inlineFragmentNode.typeCondition) == null ? void 0 : _a.name.value;\n          const dataTypename = match(data3).with({ __typename: P.select(P.string) }, (name) => name).with(\n            { __typename: P.array({ __typename: P.select(P.string) }) },\n            (name) => name[0]\n          ).otherwise(() => void 0);\n          if (typeCondition != null && dataTypename != null) {\n            if (cache.isTypeCompatible(dataTypename, typeCondition)) {\n              return traverse(\n                inlineFragmentNode.selectionSet,\n                data3\n              );\n            } else {\n              if (inlineFragmentNode.selectionSet.selections.some(\n                (selection2) => selection2.kind === Kind.INLINE_FRAGMENT\n              )) {\n                return traverse(\n                  {\n                    ...inlineFragmentNode.selectionSet,\n                    selections: inlineFragmentNode.selectionSet.selections.filter(\n                      (selection2) => {\n                        var _a2;\n                        if (selection2.kind === Kind.INLINE_FRAGMENT) {\n                          const typeCondition2 = (_a2 = selection2.typeCondition) == null ? void 0 : _a2.name.value;\n                          if (typeCondition2 == null) {\n                            return true;\n                          } else {\n                            return cache.isTypeCompatible(\n                              dataTypename,\n                              typeCondition2\n                            );\n                          }\n                        }\n                        return true;\n                      }\n                    )\n                  },\n                  data3\n                );\n              } else {\n                return Option.Some(data3);\n              }\n            }\n          }\n          return traverse(\n            inlineFragmentNode.selectionSet,\n            data3\n          );\n        } else {\n          return Option.None();\n        }\n      });\n    }, Option.Some(data));\n  };\n  return Array$1.findMap(\n    document.definitions,\n    (definition) => definition.kind === Kind.OPERATION_DEFINITION ? Option.Some(definition) : Option.None()\n  ).flatMap(\n    (operation) => getCacheKeyFromOperationNode(operation).map((cacheKey) => ({\n      operation,\n      cacheKey\n    }))\n  ).flatMap(({ operation, cacheKey }) => {\n    return cache.getFromCache(cacheKey, getSelectedKeys(operation, variables)).map((cache2) => ({ cache: cache2, operation }));\n  }).flatMap(({ operation, cache: cache2 }) => {\n    return traverse(\n      operation.selectionSet,\n      cache2\n    );\n  }).map((data) => JSON.parse(JSON.stringify(data))).flatMap((value) => {\n    var _a;\n    const serializedVariables = serializeVariables(variables);\n    const previous = Option.fromNullable(STABILITY_CACHE.get(document)).flatMap(\n      (byVariable) => Option.fromNullable(byVariable.get(serializedVariables))\n    ).flatMap((value2) => value2);\n    if (previous.flatMap((previous2) => previous2.toOption()).map((previous2) => deepEqual(value, previous2)).getOr(false)) {\n      return previous;\n    } else {\n      const valueToCache = Option.Some(Result.Ok(value));\n      const documentCache = (_a = STABILITY_CACHE.get(document)) != null ? _a : /* @__PURE__ */ new Map();\n      documentCache.set(serializedVariables, valueToCache);\n      STABILITY_CACHE.set(document, documentCache);\n      return valueToCache;\n    }\n  });\n};\nvar optimizeQuery = (cache, document, variables) => {\n  const traverse = (selections, data, parentSelectedKeys) => {\n    const nextSelections = Array$1.filterMap(\n      selections.selections,\n      (selection) => {\n        return match(selection).with({ kind: Kind.FIELD }, (fieldNode) => {\n          const fieldNameWithArguments = getFieldNameWithArguments(\n            fieldNode,\n            variables\n          );\n          if (data == void 0) {\n            return Option.Some(fieldNode);\n          }\n          const cacheHasKey = hasOwnProperty.call(\n            data,\n            fieldNameWithArguments\n          );\n          if (!cacheHasKey) {\n            return Option.Some(fieldNode);\n          }\n          if (parentSelectedKeys.has(fieldNameWithArguments)) {\n            const valueOrKeyFromCache = data[fieldNameWithArguments];\n            const subFieldSelectedKeys = getSelectedKeys(\n              fieldNode,\n              variables\n            );\n            if (Array$1.isArray(valueOrKeyFromCache)) {\n              return valueOrKeyFromCache.reduce((acc, valueOrKey) => {\n                const value = getFromCacheOrReturnValueWithoutKeyFilter(\n                  cache,\n                  valueOrKey\n                );\n                if (value.isNone()) {\n                  return Option.Some(fieldNode);\n                }\n                const originalSelectionSet = fieldNode.selectionSet;\n                if (originalSelectionSet != null) {\n                  return traverse(\n                    originalSelectionSet,\n                    value.get(),\n                    subFieldSelectedKeys\n                  ).map((selectionSet) => ({\n                    ...fieldNode,\n                    selectionSet: addIdIfPreviousSelected(\n                      originalSelectionSet,\n                      selectionSet\n                    )\n                  }));\n                } else {\n                  return acc;\n                }\n              }, Option.None());\n            } else {\n              const value = getFromCacheOrReturnValueWithoutKeyFilter(\n                cache,\n                valueOrKeyFromCache\n              );\n              if (value.isNone()) {\n                return Option.Some(fieldNode);\n              }\n              const originalSelectionSet = fieldNode.selectionSet;\n              if (originalSelectionSet != null) {\n                return traverse(\n                  originalSelectionSet,\n                  value.get(),\n                  subFieldSelectedKeys\n                ).map((selectionSet) => ({\n                  ...fieldNode,\n                  selectionSet: addIdIfPreviousSelected(\n                    originalSelectionSet,\n                    selectionSet\n                  )\n                }));\n              } else {\n                return Option.None();\n              }\n            }\n          } else {\n            return Option.Some(fieldNode);\n          }\n        }).with({ kind: Kind.INLINE_FRAGMENT }, (inlineFragmentNode) => {\n          return traverse(\n            inlineFragmentNode.selectionSet,\n            data,\n            parentSelectedKeys\n          ).map(\n            (selectionSet) => ({ ...inlineFragmentNode, selectionSet })\n          );\n        }).with({ kind: Kind.FRAGMENT_SPREAD }, () => {\n          return Option.None();\n        }).exhaustive();\n      }\n    );\n    if (nextSelections.length > 0) {\n      return Option.Some({ ...selections, selections: nextSelections });\n    } else {\n      return Option.None();\n    }\n  };\n  return Array$1.findMap(\n    document.definitions,\n    (definition) => definition.kind === Kind.OPERATION_DEFINITION ? Option.Some(definition) : Option.None()\n  ).flatMap(\n    (operation) => getCacheKeyFromOperationNode(operation).map((cacheKey) => ({\n      operation,\n      cacheKey\n    }))\n  ).flatMap(({ operation, cacheKey }) => {\n    const selectedKeys = getSelectedKeys(operation, variables);\n    return cache.getFromCache(cacheKey, selectedKeys).map((cache2) => ({ cache: cache2, operation, selectedKeys }));\n  }).flatMap(({ operation, cache: cache2, selectedKeys }) => {\n    return traverse(\n      operation.selectionSet,\n      cache2,\n      selectedKeys\n    ).map((selectionSet) => ({\n      ...document,\n      definitions: [\n        {\n          ...operation,\n          selectionSet\n        }\n      ]\n    }));\n  });\n};\nvar writeOperationToCache = (cache, document, response, variables) => {\n  const traverse = (selections, data, path = [], rootTypename) => {\n    selections.selections.forEach((selection) => {\n      match(selection).with({ kind: Kind.FIELD }, (fieldNode) => {\n        const originalFieldName = getFieldName(fieldNode);\n        const fieldNameWithArguments = getFieldNameWithArguments(\n          fieldNode,\n          variables\n        );\n        const fieldArguments = extractArguments(fieldNode, variables);\n        const parent = data[data.length - 1];\n        const fieldValue = parent[originalFieldName];\n        const selectedKeys = getSelectedKeys(fieldNode, variables);\n        if (fieldValue != void 0) {\n          if (Array.isArray(fieldValue)) {\n            cache.updateFieldInClosestCachedAncestor({\n              originalFieldName,\n              fieldNameWithArguments,\n              value: fieldValue,\n              path,\n              ancestors: data,\n              variables: fieldArguments,\n              rootTypename,\n              selectedKeys\n            });\n            const nextValue = Array(fieldValue.length);\n            cache.updateFieldInClosestCachedAncestor({\n              originalFieldName,\n              fieldNameWithArguments,\n              value: nextValue,\n              path: [...path, fieldNameWithArguments],\n              ancestors: [...data, fieldValue],\n              variables: fieldArguments,\n              rootTypename,\n              selectedKeys\n            });\n            fieldValue.forEach((item, index) => {\n              const value = cache.cacheIfEligible(item, selectedKeys);\n              cache.updateFieldInClosestCachedAncestor({\n                originalFieldName: index.toString(),\n                fieldNameWithArguments: index.toString(),\n                value,\n                path: [...path, fieldNameWithArguments],\n                ancestors: [...data, fieldValue],\n                variables: fieldArguments,\n                rootTypename,\n                selectedKeys\n              });\n              if (isRecord(item)) {\n                traverse(\n                  fieldNode.selectionSet,\n                  [...data, fieldValue, item],\n                  [...path, fieldNameWithArguments, index.toString()],\n                  rootTypename\n                );\n              }\n            });\n          } else {\n            const value = cache.cacheIfEligible(fieldValue, selectedKeys);\n            cache.updateFieldInClosestCachedAncestor({\n              originalFieldName,\n              fieldNameWithArguments,\n              value,\n              path,\n              ancestors: data,\n              variables: fieldArguments,\n              rootTypename,\n              selectedKeys\n            });\n            if (isRecord(fieldValue) && fieldNode.selectionSet != void 0) {\n              traverse(\n                fieldNode.selectionSet,\n                [...data, fieldValue],\n                [...path, fieldNameWithArguments],\n                rootTypename\n              );\n            }\n          }\n        } else {\n          if (originalFieldName in parent) {\n            cache.updateFieldInClosestCachedAncestor({\n              originalFieldName,\n              fieldNameWithArguments,\n              value: fieldValue,\n              path,\n              ancestors: data,\n              variables: fieldArguments,\n              rootTypename,\n              selectedKeys\n            });\n          }\n        }\n      }).with({ kind: Kind.INLINE_FRAGMENT }, (inlineFragmentNode) => {\n        traverse(inlineFragmentNode.selectionSet, data, path, rootTypename);\n      }).with({ kind: Kind.FRAGMENT_SPREAD }, () => {\n      }).exhaustive();\n    });\n  };\n  document.definitions.forEach((definition) => {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      const rootTypename = match(definition.operation).with(OperationTypeNode.QUERY, () => \"Query\").with(OperationTypeNode.SUBSCRIPTION, () => \"Subscription\").with(OperationTypeNode.MUTATION, () => \"Mutation\").exhaustive();\n      cache.cacheIfEligible(\n        isRecord(response) ? {\n          ...response,\n          __typename: rootTypename\n        } : response,\n        getSelectedKeys(definition, variables)\n      );\n      traverse(definition.selectionSet, [response], [], rootTypename);\n    }\n  });\n  return cache;\n};\nvar InvalidGraphQLResponseError = class _InvalidGraphQLResponseError extends Error {\n  constructor(response) {\n    super(\"Received an invalid GraphQL response\");\n    Object.setPrototypeOf(this, _InvalidGraphQLResponseError.prototype);\n    this.name = \"InvalidGraphQLResponseError\";\n    this.response = response;\n  }\n};\nvar parseGraphQLError = (error) => {\n  return match(error).with(\n    {\n      message: P.string,\n      nodes: P.optional(P.any),\n      source: P.optional(P.any),\n      positions: P.optional(P.any),\n      path: P.optional(P.any),\n      error: P.optional(P.any),\n      extensions: P.optional(P.any)\n    },\n    ({ message, nodes: nodes2, source, positions, path, error: error2, extensions }) => {\n      const originalError = match(error2).with({ message: P.string }, ({ message: message2 }) => new Error(message2)).otherwise(() => void 0);\n      return new GraphQLError(\n        message,\n        nodes2,\n        source,\n        positions,\n        path,\n        originalError,\n        extensions\n      );\n    }\n  ).otherwise((error2) => new GraphQLError(JSON.stringify(error2)));\n};\nvar ClientError = {\n  toArray: (clientError) => {\n    return Array.isArray(clientError) ? clientError : [clientError];\n  },\n  forEach: (clientError, func) => {\n    ClientError.toArray(clientError).forEach(func);\n  }\n};\n\n// src/graphql/print.ts\nvar printString = (string) => {\n  return JSON.stringify(string);\n};\nvar printBlockString = (string) => {\n  return '\"\"\"' + string.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n};\nvar hasItems = (array) => Boolean(array && array.length);\nvar MAX_LINE_LENGTH = 80;\nvar nodes = {\n  OperationDefinition(node) {\n    if (node.operation === \"query\" && !node.name && !hasItems(node.variableDefinitions) && !hasItems(node.directives)) {\n      return nodes.SelectionSet(node.selectionSet);\n    }\n    let out = node.operation;\n    if (node.name)\n      out += \" \" + node.name.value;\n    if (hasItems(node.variableDefinitions)) {\n      if (!node.name)\n        out += \" \";\n      out += \"(\" + node.variableDefinitions.map(nodes.VariableDefinition).join(\", \") + \")\";\n    }\n    if (hasItems(node.directives))\n      out += \" \" + node.directives.map(nodes.Directive).join(\" \");\n    return out + \" \" + nodes.SelectionSet(node.selectionSet);\n  },\n  VariableDefinition(node) {\n    let out = nodes.Variable(node.variable) + \": \" + print(node.type);\n    if (node.defaultValue)\n      out += \" = \" + print(node.defaultValue);\n    if (hasItems(node.directives))\n      out += \" \" + node.directives.map(nodes.Directive).join(\" \");\n    return out;\n  },\n  Field(node) {\n    let out = (node.alias ? node.alias.value + \": \" : \"\") + node.name.value;\n    if (hasItems(node.arguments)) {\n      const args = node.arguments.map(nodes.Argument);\n      const argsLine = out + \"(\" + args.join(\", \") + \")\";\n      out = argsLine.length > MAX_LINE_LENGTH ? out + \"(\" + args.join(\" \") + \")\" : argsLine;\n    }\n    if (hasItems(node.directives))\n      out += \" \" + node.directives.map(nodes.Directive).join(\" \");\n    return node.selectionSet ? out + \" \" + nodes.SelectionSet(node.selectionSet) : out;\n  },\n  StringValue(node) {\n    return node.block ? printBlockString(node.value) : printString(node.value);\n  },\n  BooleanValue(node) {\n    return String(node.value);\n  },\n  NullValue() {\n    return \"null\";\n  },\n  IntValue(node) {\n    return node.value;\n  },\n  FloatValue(node) {\n    return node.value;\n  },\n  EnumValue(node) {\n    return node.value;\n  },\n  Name(node) {\n    return node.value;\n  },\n  Variable(node) {\n    return \"$\" + node.name.value;\n  },\n  ListValue(node) {\n    return \"[\" + node.values.map(print).join(\", \") + \"]\";\n  },\n  ObjectValue(node) {\n    return \"{\" + node.fields.map(nodes.ObjectField).join(\", \") + \"}\";\n  },\n  ObjectField(node) {\n    return node.name.value + \": \" + print(node.value);\n  },\n  Document(node) {\n    return hasItems(node.definitions) ? node.definitions.map(print).join(\" \") : \"\";\n  },\n  SelectionSet(node) {\n    return \"{\" + node.selections.map(print).join(\" \") + \"}\";\n  },\n  Argument(node) {\n    return node.name.value + \": \" + print(node.value);\n  },\n  FragmentSpread(node) {\n    let out = \"...\" + node.name.value;\n    if (hasItems(node.directives))\n      out += \" \" + node.directives.map(nodes.Directive).join(\" \");\n    return out;\n  },\n  InlineFragment(node) {\n    let out = \"...\";\n    if (node.typeCondition)\n      out += \" on \" + node.typeCondition.name.value;\n    if (hasItems(node.directives))\n      out += \" \" + node.directives.map(nodes.Directive).join(\" \");\n    return out + \" \" + print(node.selectionSet);\n  },\n  FragmentDefinition(node) {\n    let out = \"fragment \" + node.name.value;\n    out += \" on \" + node.typeCondition.name.value;\n    if (hasItems(node.directives))\n      out += \" \" + node.directives.map(nodes.Directive).join(\" \");\n    return out + \" \" + print(node.selectionSet);\n  },\n  Directive(node) {\n    let out = \"@\" + node.name.value;\n    if (hasItems(node.arguments))\n      out += \"(\" + node.arguments.map(nodes.Argument).join(\", \") + \")\";\n    return out;\n  },\n  NamedType(node) {\n    return node.name.value;\n  },\n  ListType(node) {\n    return \"[\" + print(node.type) + \"]\";\n  },\n  NonNullType(node) {\n    return print(node.type) + \"!\";\n  }\n};\nvar print = (node) => {\n  return typeof nodes[node.kind] == \"function\" ? nodes[node.kind](node) : \"\";\n};\n\n// src/client.ts\nvar defaultMakeRequest = ({\n  url,\n  headers,\n  operationName,\n  withCredentials,\n  document,\n  variables\n}) => {\n  return Request.make({\n    url,\n    method: \"POST\",\n    responseType: \"json\",\n    headers,\n    withCredentials: Option.fromNullable(withCredentials).getOr(false),\n    body: JSON.stringify({\n      operationName,\n      query: print(document),\n      variables\n    })\n  }).mapOkToResult(badStatusToError).mapOkToResult(emptyToError).mapOkToResult(\n    (payload) => match(payload).returnType().with(\n      { errors: P.select(P.array()) },\n      (errors) => Result.Error(errors.map(parseGraphQLError))\n    ).with({ data: P.select(P.nonNullable) }, (data) => Result.Ok(data)).otherwise(\n      (response) => Result.Error(new InvalidGraphQLResponseError(response))\n    )\n  );\n};\nvar prepend = (connection, edges) => {\n  return [connection, { prepend: edges }];\n};\nvar append = (connection, edges) => {\n  return [connection, { append: edges }];\n};\nvar remove = (connection, ids) => {\n  return [connection, { remove: ids }];\n};\nvar Client = class {\n  constructor(config) {\n    var _a, _b;\n    this.url = config.url;\n    this.headers = (_a = config.headers) != null ? _a : { \"Content-Type\": \"application/json\" };\n    this.schemaConfig = config.schemaConfig;\n    this.cache = new ClientCache(config.schemaConfig);\n    this.makeRequest = (_b = config.makeRequest) != null ? _b : defaultMakeRequest;\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.transformedDocuments = /* @__PURE__ */ new Map();\n    this.transformedDocumentsForRequest = /* @__PURE__ */ new Map();\n  }\n  getTransformedDocument(document) {\n    if (this.transformedDocuments.has(document)) {\n      return this.transformedDocuments.get(document);\n    } else {\n      const transformedDocument = inlineFragments(addTypenames(document));\n      this.transformedDocuments.set(document, transformedDocument);\n      return transformedDocument;\n    }\n  }\n  getTransformedDocumentsForRequest(document) {\n    if (this.transformedDocumentsForRequest.has(document)) {\n      return this.transformedDocumentsForRequest.get(document);\n    } else {\n      const transformedDocument = addTypenames(document);\n      this.transformedDocumentsForRequest.set(document, transformedDocument);\n      return transformedDocument;\n    }\n  }\n  subscribe(func) {\n    this.subscribers.add(func);\n    return () => this.subscribers.delete(func);\n  }\n  request(document, variables, {\n    optimize = false,\n    connectionUpdates,\n    overrides\n  } = {}) {\n    const transformedDocument = this.getTransformedDocument(document);\n    const transformedDocumentsForRequest = this.getTransformedDocumentsForRequest(document);\n    const operationName = getExecutableOperationName(transformedDocument).getOr(\"Untitled\");\n    const variablesAsRecord = variables;\n    const possiblyOptimizedQuery = optimize ? optimizeQuery(this.cache, transformedDocument, variablesAsRecord).map(\n      addTypenames\n    ) : Option.Some(transformedDocumentsForRequest);\n    if (possiblyOptimizedQuery.isNone()) {\n      const operationResult = readOperationFromCache(\n        this.cache,\n        transformedDocument,\n        variablesAsRecord\n      );\n      if (operationResult.isSome()) {\n        return Future.value(operationResult.get());\n      }\n    }\n    return this.makeRequest({\n      url: this.url,\n      operationName,\n      document: possiblyOptimizedQuery.getOr(transformedDocumentsForRequest),\n      variables: variablesAsRecord,\n      ...overrides,\n      headers: {\n        ...this.headers,\n        ...overrides != null ? overrides.headers : null\n      }\n    }).mapOk((data) => data).tapOk((data) => {\n      writeOperationToCache(\n        this.cache,\n        transformedDocument,\n        data,\n        variablesAsRecord\n      );\n    }).tapOk((data) => {\n      if (connectionUpdates !== void 0) {\n        connectionUpdates.forEach((getUpdate) => {\n          getUpdate({ data, variables, prepend, append, remove }).map(\n            ([connection, update]) => {\n              this.cache.updateConnection(connection, update);\n            }\n          );\n        });\n      }\n    }).tap((result) => {\n      this.cache.setOperationInCache(\n        transformedDocument,\n        variablesAsRecord,\n        result\n      );\n      this.subscribers.forEach((func) => {\n        func();\n      });\n    });\n  }\n  readFromCache(document, variables) {\n    const variablesAsRecord = variables;\n    const transformedDocument = this.getTransformedDocument(document);\n    return match(\n      this.cache.getOperationFromCache(transformedDocument, variablesAsRecord)\n    ).with(Option.P.Some(Result.P.Error(P._)), (value) => value).otherwise(\n      () => readOperationFromCache(\n        this.cache,\n        transformedDocument,\n        variablesAsRecord\n      )\n    );\n  }\n  query(document, variables, requestOptions) {\n    return this.request(document, variables, requestOptions);\n  }\n  commitMutation(document, variables, requestOptions) {\n    return this.request(document, variables, requestOptions);\n  }\n  purge() {\n    this.cache = new ClientCache(this.schemaConfig);\n    this.subscribers.forEach((func) => {\n      func();\n    });\n  }\n};\nvar ClientContext = createContext(\n  new Client({ url: \"/graphql\", schemaConfig: { interfaceToTypes: {} } })\n);\nvar useDeferredQuery = (query, { optimize = false, debounce } = {}) => {\n  const client = useContext(ClientContext);\n  const [stableQuery] = useState(query);\n  const [stableVariables, setStableVariables] = useState(\n    Option.None()\n  );\n  const timeoutRef = useRef(void 0);\n  const getSnapshot = useCallback(() => {\n    return stableVariables.flatMap(\n      (variables) => client.readFromCache(stableQuery, variables)\n    );\n  }, [client, stableQuery, stableVariables]);\n  const data = useSyncExternalStore(\n    (func) => client.subscribe(func),\n    getSnapshot\n  );\n  const asyncData = useMemo(() => {\n    return data.map((value) => AsyncData.Done(value)).getOr(AsyncData.NotAsked());\n  }, [data]);\n  const runQuery = useCallback(\n    (variables, { overrides } = {}) => {\n      setStableVariables(\n        (stableVariables2) => stableVariables2.match({\n          None: () => Option.Some(variables),\n          Some: (prevVariables) => deepEqual(prevVariables, variables) ? stableVariables2 : Option.Some(variables)\n        })\n      );\n      return client.request(stableQuery, variables, { optimize, overrides }).tap(() => setIsQuerying(false));\n    },\n    [client, optimize, stableQuery]\n  );\n  const [isQuerying, setIsQuerying] = useState(false);\n  const exposedRunQuery = useCallback(\n    (variables, config) => {\n      if (timeoutRef.current !== void 0) {\n        clearTimeout(timeoutRef.current);\n      }\n      setIsQuerying(true);\n      if (debounce === void 0) {\n        return runQuery(variables, config);\n      } else {\n        const [future, resolve] = Deferred.make();\n        timeoutRef.current = window.setTimeout(\n          (variables2) => {\n            runQuery(variables2, config).tap(resolve);\n          },\n          debounce,\n          variables\n        );\n        return future;\n      }\n    },\n    [runQuery, debounce]\n  );\n  const reset = useCallback(() => {\n    setIsQuerying(false);\n    setStableVariables(Option.None());\n  }, []);\n  const asyncDataToExpose = isQuerying ? AsyncData.Loading() : asyncData;\n  return [asyncDataToExpose, { query: exposedRunQuery, reset }];\n};\nvar useMutation = (mutation, config = {}) => {\n  const client = useContext(ClientContext);\n  const connectionUpdatesRef = useRef(config == null ? void 0 : config.connectionUpdates);\n  connectionUpdatesRef.current = config == null ? void 0 : config.connectionUpdates;\n  const [stableMutation] = useState(mutation);\n  const [data, setData] = useState(\n    AsyncData.NotAsked()\n  );\n  const commitMutation = useCallback(\n    (variables, { overrides } = {}) => {\n      setData(AsyncData.Loading());\n      return client.commitMutation(stableMutation, variables, {\n        connectionUpdates: connectionUpdatesRef.current,\n        overrides\n      }).tap((result) => setData(AsyncData.Done(result)));\n    },\n    [client, stableMutation]\n  );\n  return [commitMutation, data];\n};\nvar mergeConnection = (previous, next, mode) => {\n  if (next == null) {\n    return next;\n  }\n  if (previous == null) {\n    return next;\n  }\n  if (\"__connectionArguments\" in next && isRecord(next.__connectionArguments)) {\n    if (next.__connectionArguments[mode] == null) {\n      return next;\n    }\n  }\n  if (mode === \"after\" && next.pageInfo.endCursor === previous.pageInfo.endCursor) {\n    return previous;\n  }\n  if (mode === \"before\" && next.pageInfo.startCursor === previous.pageInfo.startCursor) {\n    return previous;\n  }\n  return {\n    ...next,\n    __connectionCachePath: match(mode).with(\"before\", () => [\n      ...\"__connectionCachePath\" in next && Array.isArray(next.__connectionCachePath) ? next.__connectionCachePath : [],\n      ...\"__connectionCachePath\" in previous && Array.isArray(previous.__connectionCachePath) ? previous.__connectionCachePath : []\n    ]).with(\"after\", () => [\n      ...\"__connectionCachePath\" in previous && Array.isArray(previous.__connectionCachePath) ? previous.__connectionCachePath : [],\n      ...\"__connectionCachePath\" in next && Array.isArray(next.__connectionCachePath) ? next.__connectionCachePath : []\n    ]).exhaustive(),\n    edges: match(mode).with(\"before\", () => {\n      var _a, _b;\n      return [...(_a = next.edges) != null ? _a : [], ...(_b = previous.edges) != null ? _b : []];\n    }).with(\"after\", () => {\n      var _a, _b;\n      return [...(_a = previous.edges) != null ? _a : [], ...(_b = next.edges) != null ? _b : []];\n    }).exhaustive(),\n    pageInfo: match(mode).with(\"before\", () => ({\n      hasPreviousPage: next.pageInfo.hasPreviousPage,\n      startCursor: next.pageInfo.startCursor,\n      hasNextPage: previous.pageInfo.hasNextPage,\n      endCursor: previous.pageInfo.endCursor\n    })).with(\"after\", () => ({\n      hasPreviousPage: previous.pageInfo.hasPreviousPage,\n      startCursor: previous.pageInfo.startCursor,\n      hasNextPage: next.pageInfo.hasNextPage,\n      endCursor: next.pageInfo.endCursor\n    })).exhaustive()\n  };\n};\nvar createPaginationHook = (direction) => {\n  return (connection) => {\n    const connectionRef = useRef(connection);\n    connectionRef.current = mergeConnection(\n      connectionRef.current,\n      connection,\n      direction\n    );\n    return connectionRef.current;\n  };\n};\nvar useForwardPagination = createPaginationHook(\"after\");\nvar useBackwardPagination = createPaginationHook(\"before\");\nvar usePreviousValue = (value) => {\n  const previousRef = useRef(value);\n  useEffect(() => {\n    previousRef.current = value;\n  }, [value]);\n  return previousRef.current;\n};\nvar useQuery = (query, variables, { suspense = false, optimize = false, overrides } = {}) => {\n  const client = useContext(ClientContext);\n  const [stableQuery] = useState(query);\n  const [stableVariables, setStableVariables] = useState([variables, variables]);\n  const [stableOverrides, setStableOverrides] = useState(overrides);\n  useEffect(() => {\n    const [providedVariables] = stableVariables;\n    if (!deepEqual(providedVariables, variables)) {\n      setIsReloading(true);\n      setStableVariables([variables, variables]);\n    }\n  }, [stableVariables, variables]);\n  useEffect(() => {\n    if (!deepEqual(stableOverrides, overrides)) {\n      setIsReloading(true);\n      setStableOverrides(overrides);\n    }\n  }, [stableOverrides, overrides]);\n  const getSnapshot = useCallback(() => {\n    return client.readFromCache(stableQuery, stableVariables[1]);\n  }, [client, stableQuery, stableVariables]);\n  const data = useSyncExternalStore(\n    (func) => client.subscribe(func),\n    getSnapshot\n  );\n  const asyncData = useMemo(() => {\n    return data.map((value) => AsyncData.Done(value)).getOr(AsyncData.Loading());\n  }, [data]);\n  const previousAsyncData = usePreviousValue(asyncData);\n  const isSuspenseFirstFetch = useRef(true);\n  useEffect(() => {\n    if (suspense && isSuspenseFirstFetch.current) {\n      isSuspenseFirstFetch.current = false;\n      return;\n    }\n    const request = client.query(stableQuery, stableVariables[1], {\n      optimize,\n      overrides: stableOverrides\n    }).tap(() => setIsReloading(false));\n    return () => request.cancel();\n  }, [\n    client,\n    suspense,\n    optimize,\n    stableOverrides,\n    stableQuery,\n    stableVariables\n  ]);\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const refresh = useCallback(() => {\n    setIsRefreshing(true);\n    return client.query(stableQuery, stableVariables[1], { overrides: stableOverrides }).tap(() => setIsRefreshing(false));\n  }, [client, stableQuery, stableOverrides, stableVariables]);\n  const [isReloading, setIsReloading] = useState(false);\n  const reload = useCallback(() => {\n    setIsReloading(true);\n    setStableVariables(([stable]) => [stable, stable]);\n    return client.query(stableQuery, stableVariables[0], { overrides: stableOverrides }).tap(() => setIsReloading(false));\n  }, [client, stableQuery, stableOverrides, stableVariables]);\n  const isLoading = isRefreshing || isReloading || asyncData.isLoading();\n  const asyncDataToExpose = isReloading ? AsyncData.Loading() : isLoading ? previousAsyncData : asyncData;\n  if (suspense && isSuspenseFirstFetch.current && asyncDataToExpose.isLoading()) {\n    throw client.query(stableQuery, stableVariables[1], { optimize }).toPromise();\n  }\n  const setVariables = useCallback((variables2) => {\n    setStableVariables((prev) => {\n      const [prevStable, prevFinal] = prev;\n      const nextFinal = { ...prevFinal, ...variables2 };\n      if (!deepEqual(prevFinal, nextFinal)) {\n        return [prevStable, nextFinal];\n      } else {\n        return prev;\n      }\n    });\n  }, []);\n  return [asyncDataToExpose, { isLoading, refresh, reload, setVariables }];\n};\n\nexport { Client, ClientContext, ClientError, InvalidGraphQLResponseError, parseGraphQLError, print, useBackwardPagination, useDeferredQuery, useForwardPagination, useMutation, useQuery };\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map","import{useSyncExternalStoreWithSelector as e}from\"use-sync-external-store/shim/with-selector\";function t(e){const t=new Set;let r=e;return{get:()=>r,set(e){r=\"function\"==typeof e?e(r):e,t.forEach(e=>e(r))},subscribe:e=>(t.add(e),()=>{t.delete(e)}),reset(){r=e,t.forEach(e=>e(r))}}}function r(e){return e}function n(t,n){return void 0===n&&(n=Object.is),e(t.subscribe,t.get,t.get,r,n)}function o(t,r,n){return void 0===n&&(n=Object.is),e(t.subscribe,t.get,t.get,r,n)}export{t as atom,n as useAtom,o as useAtomWithSelector};\n//# sourceMappingURL=index.module.js.map\n","// based on https://gist.github.com/ncou/3a0a1f89c8e22416d0d607f621a948a9\n\nexport type ControllableTimeout = {\n  readonly duration: number;\n  readonly clear: () => void;\n  readonly reset: () => void;\n};\n\nexport const createControllableTimeout = (config: {\n  duration: number;\n  onStart: (duration: number) => void;\n  onEnd: () => void;\n  onReset: (duration: number) => void;\n}): ControllableTimeout => {\n  const { duration, onStart, onReset, onEnd } = config;\n  let timerId = 0;\n  let remaining = duration;\n\n  const clear = () => {\n    document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    window.clearTimeout(timerId);\n  };\n\n  const start = () => {\n    if (remaining <= 0) {\n      return;\n    }\n\n    timerId = window.setTimeout(() => {\n      remaining = 0;\n      clear();\n      onEnd();\n    }, remaining);\n\n    onStart(duration);\n  };\n\n  const reset = () => {\n    window.clearTimeout(timerId);\n\n    remaining = duration;\n\n    timerId = window.setTimeout(() => {\n      remaining = 0;\n      clear();\n      onEnd();\n    }, duration);\n\n    onReset(duration);\n  };\n\n  const onVisibilityChange = () => {\n    document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    start();\n  };\n\n  if (document.hidden) {\n    document.addEventListener(\"visibilitychange\", onVisibilityChange);\n  } else {\n    start();\n  }\n\n  return {\n    duration,\n    clear,\n    reset,\n  };\n};\n","import { atom, useAtom } from \"react-atomic-state\";\nimport { Animated, Easing } from \"react-native\";\nimport { ControllableTimeout, createControllableTimeout } from \"../utils/timer\";\n\nexport type ToastVariant = \"success\" | \"info\" | \"warning\" | \"error\";\n\ntype ToastContent = {\n  variant: ToastVariant;\n  title: string;\n  description?: string;\n  error?: unknown;\n  autoClose?: boolean;\n};\n\ntype Toast = {\n  uid: string;\n  variant: ToastVariant;\n  title: string;\n  description?: string;\n  error?: unknown;\n  progress?: Animated.Value;\n  timeout?: ControllableTimeout;\n};\n\nconst toasts = atom<Toast[]>([]);\n\nexport const useToasts = () => useAtom(toasts);\n\nexport const hideToast = (uid: string) => {\n  const toast = toasts.get().find(toast => toast.uid === uid);\n\n  if (!toast) {\n    return;\n  }\n\n  toast.timeout?.clear();\n  toast.progress?.stopAnimation();\n\n  toasts.set(toasts => toasts.filter(toast => toast.uid !== uid));\n};\n\nlet errorToRequestId = new WeakMap<WeakKey, string>();\n\nexport const registerErrorToRequestId = (value: WeakMap<WeakKey, string>) => {\n  errorToRequestId = value;\n};\n\nexport const getErrorToRequestId = () => {\n  return errorToRequestId;\n};\n\nexport const showToast = ({ variant, title, description, error, autoClose }: ToastContent) => {\n  const uid = `${variant} - ${title} - ${description ?? \"\"}`;\n\n  const toast = toasts.get().find(toast => toast.uid === uid);\n\n  if (toast != null) {\n    if (toast.timeout && toast.progress) {\n      toast.timeout.clear();\n\n      Animated.timing(toast.progress, {\n        duration: 100,\n        easing: Easing.linear,\n        toValue: 1,\n        useNativeDriver: false,\n      }).start(() => {\n        toast.timeout?.reset();\n      });\n    }\n\n    return uid;\n  }\n\n  // by default, only info and success toasts are auto-closing\n  const isAutoClosingToast = autoClose ?? (variant === \"info\" || variant === \"success\");\n\n  const progress = isAutoClosingToast ? new Animated.Value(1) : undefined;\n\n  const timeout = progress\n    ? createControllableTimeout({\n        duration: 10000,\n        onStart: duration => {\n          Animated.timing(progress, {\n            duration,\n            easing: Easing.linear,\n            toValue: 0,\n            useNativeDriver: false,\n          }).start();\n        },\n        onReset: duration => {\n          Animated.timing(progress, {\n            duration,\n            easing: Easing.linear,\n            toValue: 0,\n            useNativeDriver: false,\n          }).start();\n        },\n        onEnd: () => {\n          hideToast(uid);\n        },\n      })\n    : undefined;\n\n  toasts.set(toasts => [{ uid, variant, title, description, error, progress, timeout }, ...toasts]);\n  return uid;\n};\n","import { Array, Option } from \"@swan-io/boxed\";\nimport { ClientError } from \"@swan-io/graphql-client\";\nimport { t } from \"@swan-io/shared-business/src/utils/i18n\";\nimport { memo, useEffect, useRef, useState } from \"react\";\nimport { Animated, Clipboard, StyleSheet, View } from \"react-native\";\nimport { P, match } from \"ts-pattern\";\nimport { ColorVariants, animations, colors, shadows } from \"../constants/design\";\nimport { ToastVariant, getErrorToRequestId, hideToast, useToasts } from \"../state/toasts\";\nimport { isNotNullishOrEmpty, isNullish } from \"../utils/nullish\";\nimport { Box } from \"./Box\";\nimport { Icon } from \"./Icon\";\nimport { LakeText } from \"./LakeText\";\nimport { LakeTooltip } from \"./LakeTooltip\";\nimport { Portal } from \"./Portal\";\nimport { Pressable } from \"./Pressable\";\nimport { Space } from \"./Space\";\nimport { TransitionGroupView } from \"./TransitionGroupView\";\n\nconst styles = StyleSheet.create({\n  list: {\n    position: \"absolute\",\n    right: 0,\n    bottom: 0,\n    maxHeight: \"100%\",\n    maxWidth: 400,\n    paddingVertical: 8,\n    width: \"100%\",\n    zIndex: 10,\n  },\n  toastWrapper: {\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n  },\n  toast: {\n    padding: 24,\n    borderRadius: 4,\n    borderWidth: 1,\n    borderLeftWidth: 4,\n    overflow: \"hidden\",\n    boxShadow: shadows.modal,\n  },\n  contentContainer: {\n    paddingRight: 36, // 24 for close button + 12 for spacing\n  },\n  closeButton: {\n    zIndex: 1,\n    position: \"absolute\",\n    width: 24,\n    height: 24,\n    right: 24,\n    top: 0,\n    bottom: 0,\n    margin: \"auto\",\n  },\n  progressBar: {\n    height: 2,\n    transformOrigin: \"left\",\n  },\n  copyTooltip: {\n    alignSelf: \"flex-start\",\n  },\n  copyButton: {\n    alignItems: \"center\",\n    flexDirection: \"row\",\n    flexGrow: 1,\n    flexShrink: 1,\n  },\n});\n\ntype ToastProps = {\n  variant: ToastVariant;\n  uid: string;\n  title: string;\n  description?: string;\n  error?: unknown;\n  progress?: Animated.Value;\n  onClose: (uid: string) => void;\n};\n\nconst Toast = memo<ToastProps>(({ variant, uid, title, description, error, progress, onClose }) => {\n  const progressBarRef = useRef<View>(null);\n  const [visibleState, setVisibleState] = useState<\"copy\" | \"copied\">(\"copy\");\n  const hasDescription = isNotNullishOrEmpty(description);\n\n  const [requestId] = useState<Option<string>>(() => {\n    if (error == undefined) {\n      return Option.None();\n    }\n    return Array.findMap(ClientError.toArray(error as ClientError), error => {\n      if (error instanceof Error) {\n        return Option.fromNullable(getErrorToRequestId().get(error));\n      } else {\n        return Option.None();\n      }\n    });\n  });\n\n  const colorVariation = match(variant)\n    .returnType<ColorVariants>()\n    .with(\"success\", () => \"positive\")\n    .with(\"error\", () => \"negative\")\n    .with(\"info\", () => \"shakespear\")\n    .with(\"warning\", () => \"warning\")\n    .exhaustive();\n\n  useEffect(() => {\n    if (isNullish(progress)) {\n      return;\n    }\n\n    const id = progress.addListener(({ value }) => {\n      if (progressBarRef.current instanceof HTMLElement) {\n        progressBarRef.current.style.transform = `scaleX(${value})`;\n      }\n    });\n\n    return () => progress.removeListener(id);\n  }, [progress]);\n\n  return (\n    <View style={styles.toastWrapper}>\n      <View\n        style={[\n          styles.toast,\n          {\n            borderColor: colors[colorVariation][200],\n            borderLeftColor: colors[colorVariation][500],\n            backgroundColor: colors[colorVariation][0],\n          },\n        ]}\n      >\n        <Box style={styles.contentContainer}>\n          <Box direction=\"row\" alignItems=\"center\">\n            {match(variant)\n              .with(\"success\", () => (\n                <Icon\n                  name=\"checkmark-circle-regular\"\n                  size={20}\n                  color={colors[colorVariation][700]}\n                />\n              ))\n              .with(\"error\", () => (\n                <Icon name=\"dismiss-circle-regular\" size={20} color={colors[colorVariation][700]} />\n              ))\n              .with(\"info\", () => (\n                <Icon name=\"info-regular\" size={20} color={colors[colorVariation][700]} />\n              ))\n              .with(\"warning\", () => (\n                <Icon name=\"warning-regular\" size={20} color={colors[colorVariation][700]} />\n              ))\n              .exhaustive()}\n\n            <Space width={12} />\n\n            <LakeText variant=\"regular\" color={colors[colorVariation][700]}>\n              {title}\n            </LakeText>\n          </Box>\n\n          {hasDescription && (\n            <>\n              <Space height={8} />\n\n              <LakeText variant=\"smallRegular\" color={colors.gray[700]}>\n                {description}\n              </LakeText>\n            </>\n          )}\n\n          {match(requestId)\n            .with(Option.P.None, () => null)\n            .with(Option.P.Some(P.select()), requestId => (\n              <>\n                <Space height={hasDescription ? 4 : 8} />\n\n                <LakeTooltip\n                  describedBy=\"copy\"\n                  onHide={() => setVisibleState(\"copy\")}\n                  togglableOnFocus={true}\n                  placement=\"center\"\n                  containerStyle={styles.copyTooltip}\n                  content={\n                    visibleState === \"copy\"\n                      ? t(\"copyButton.copyTooltip\")\n                      : t(\"copyButton.copiedTooltip\")\n                  }\n                >\n                  <Pressable\n                    style={styles.copyButton}\n                    onPress={event => {\n                      event.stopPropagation();\n                      event.preventDefault();\n                      Clipboard.setString(requestId ?? \"\");\n                      setVisibleState(\"copied\");\n                    }}\n                  >\n                    <Icon color={colors.gray[700]} size={14} name=\"copy-regular\" />\n                    <Space width={4} />\n\n                    <LakeText numberOfLines={1} variant=\"smallRegular\" color={colors.gray[700]}>\n                      ID: {requestId}\n                    </LakeText>\n                  </Pressable>\n                </LakeTooltip>\n              </>\n            ))\n            .exhaustive()}\n        </Box>\n\n        <Pressable onPress={() => onClose(uid)} style={styles.closeButton}>\n          <Icon name=\"lake-close\" size={24} color={colors.gray[500]} />\n        </Pressable>\n\n        {progress != null && (\n          <>\n            <Space height={24} />\n\n            <View\n              ref={progressBarRef}\n              role=\"progressbar\"\n              style={[styles.progressBar, { backgroundColor: colors[colorVariation][500] }]}\n            />\n          </>\n        )}\n      </View>\n    </View>\n  );\n});\n\nexport const ToastStack = () => {\n  const toasts = useToasts();\n\n  const [rootElement, setRootElement] = useState<Element | undefined>(() => undefined);\n\n  useEffect(() => {\n    const rootElement = document.createElement(\"div\");\n    document.body.append(rootElement);\n    setRootElement(rootElement);\n    return () => {\n      rootElement.remove();\n      setRootElement(undefined);\n    };\n  }, []);\n\n  if (rootElement == null) {\n    return null;\n  }\n\n  return (\n    <Portal container={rootElement}>\n      <TransitionGroupView\n        style={styles.list}\n        enter={animations.fadeAndSlideInFromRight.enter}\n        leave={animations.fadeAndSlideInFromRight.leave}\n      >\n        {toasts.map(toast => (\n          <Toast\n            key={toast.uid}\n            uid={toast.uid}\n            variant={toast.variant}\n            title={toast.title}\n            description={toast.description}\n            error={toast.error}\n            progress={toast.progress}\n            onClose={hideToast}\n          />\n        ))}\n      </TransitionGroupView>\n    </Portal>\n  );\n};\n"],"names":["e","r","GraphQLError","i","n","a","t","l","o","u","v","c","visit","traverse","d","s","f","m","g","p","h","DEEP_MERGE_DELETE","REQUESTED_KEYS","deepMerge","target","source","next","name","isRecord","containsAll","b","key","value","hasOwnProperty","deepEqual","aKeys","bKeys","serializeVariables","variables","getCacheKeyFromJson","json","match","P","Option","id","getCacheKeyFromOperationNode","operationNode","OperationTypeNode","ClientCache","schemaConfig","typename","typeCondition","compatibleTypes","documentNode","serializedVariables","cache","data","documentCache","cacheKey","requestedKeys","entry","cacheKeyOption","existingEntry","originalFieldName","fieldNameWithArguments","path","ancestors","rootTypename","selectedKeys","ancestorsCopy","pathCopy","writePath","ancestor","maybeCacheKey","Array$1","item","deepUpdate","acc","updater","cachedAncestor","acc2","connection","config","__connectionCacheKey","__connectionCachePath","cachePath","typenameSymbol","edgesSymbol","nodeSymbol","edges","firstPath","node","__typename","lastPath","nodeIds","edge","nodeId","_a","getSelectedKeys","fieldNode","selections","selection","Kind","getFieldNameWithArguments","fieldName","getFieldName","args","extractArguments","extractValue","valueNode","values","fields","inlineFragments","fragmentMap","inline","fragmentName","fragmentNode","TYPENAME_NODE","addTypenames","selectionSet","getExecutableOperationName","document","definition","getIdFieldNode","inlineFragmentNode","addIdIfPreviousSelected","oldSelectionSet","newSelectionSet","idSelection","isExcluded","directive","arg","getFromCacheOrReturnValue","valueOrKey","getFromCacheOrReturnValueWithoutKeyFilter","STABILITY_CACHE","EXCLUDED","readOperationFromCache","data2","data3","valueOrKeyFromCache","value2","result","dataTypename","selection2","_a2","typeCondition2","operation","cache2","previous","byVariable","previous2","valueToCache","Result","optimizeQuery","parentSelectedKeys","nextSelections","subFieldSelectedKeys","originalSelectionSet","writeOperationToCache","response","fieldArguments","parent","fieldValue","nextValue","index","InvalidGraphQLResponseError","_InvalidGraphQLResponseError","parseGraphQLError","error","message","nodes2","positions","error2","extensions","originalError","message2","ClientError","clientError","func","printString","string","printBlockString","hasItems","array","MAX_LINE_LENGTH","nodes","out","print","argsLine","defaultMakeRequest","url","headers","operationName","withCredentials","Request","badStatusToError","emptyToError","payload","errors","prepend","append","remove","ids","Client","_b","transformedDocument","optimize","connectionUpdates","overrides","transformedDocumentsForRequest","variablesAsRecord","possiblyOptimizedQuery","operationResult","Future","getUpdate","update","requestOptions","createContext","createControllableTimeout","duration","onStart","onReset","onEnd","timerId","remaining","clear","onVisibilityChange","start","reset","toasts","atom","useToasts","useAtom","hideToast","uid","toast","errorToRequestId","registerErrorToRequestId","getErrorToRequestId","showToast","variant","title","description","autoClose","Animated","Easing","progress","timeout","styles","StyleSheet","shadows","Toast","memo","onClose","progressBarRef","useRef","visibleState","setVisibleState","useState","hasDescription","isNotNullishOrEmpty","requestId","Array","colorVariation","useEffect","isNullish","jsx","View","jsxs","colors","Box","Icon","Space","LakeText","Fragment","LakeTooltip","Pressable","event","Clipboard","ToastStack","rootElement","setRootElement","Portal","TransitionGroupView","animations"],"mappings":"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","x_google_ignoreList":[0,1,2]}